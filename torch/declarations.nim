# Automatically generated, to update run again the generator from the torch root path
# nim c -r torch/generator.nim

proc storage_offset*(ty: TensorType; self: Tensor): int64 {.inline, noinit.} = ty.dynamicCppCall("storage_offset", self.tensor).to(int64)
proc storage_offset*(self: Tensor): int64 {.inline, noinit.} = self.tensor.dynamicCppCall("storage_offset").to(int64)
proc resize_u*(ty: TensorType; self: Tensor, size: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("resize_", self.tensor, size).to(ATensor).newTensor()
proc resize_u*(self: Tensor, size: IntList): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("resize_", size).to(ATensor).newTensor()
proc set_u*(ty: TensorType; self: Tensor, source: AStorage): Tensor {.inline, noinit.} = ty.dynamicCppCall("set_", self.tensor, source).to(ATensor).newTensor()
proc set_u*(self: Tensor, source: AStorage): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("set_", source).to(ATensor).newTensor()
proc set_u*(ty: TensorType; self: Tensor, source: AStorage, storage_offset: int64, size: IntList, stride: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("set_", self.tensor, source, storage_offset, size, stride).to(ATensor).newTensor()
proc set_u*(self: Tensor, source: AStorage, storage_offset: int64, size: IntList, stride: IntList): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("set_", source, storage_offset, size, stride).to(ATensor).newTensor()
proc set_u*(ty: TensorType; self: Tensor, source: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("set_", self.tensor, source.tensor).to(ATensor).newTensor()
proc set_u*(self: Tensor, source: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("set_", source.tensor).to(ATensor).newTensor()
proc set_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("set_", self.tensor).to(ATensor).newTensor()
proc set_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("set_").to(ATensor).newTensor()
proc u_fill_u*(ty: TensorType; self: Tensor, value: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("_fill_", self.tensor, value).to(ATensor).newTensor()
proc u_fill_u*(self: Tensor, value: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_fill_", value).to(ATensor).newTensor()
proc u_fill_u*(ty: TensorType; self: Tensor, value: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_fill_", self.tensor, value.tensor).to(ATensor).newTensor()
proc u_fill_u*(self: Tensor, value: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_fill_", value.tensor).to(ATensor).newTensor()
proc is_contiguous*(ty: TensorType; self: Tensor): bool {.inline, noinit.} = ty.dynamicCppCall("is_contiguous", self.tensor).to(bool)
proc is_contiguous*(self: Tensor): bool {.inline, noinit.} = self.tensor.dynamicCppCall("is_contiguous").to(bool)
proc is_set_to*(ty: TensorType; self: Tensor, tensor: Tensor): bool {.inline, noinit.} = ty.dynamicCppCall("is_set_to", self.tensor, tensor.tensor).to(bool)
proc is_set_to*(self: Tensor, tensor: Tensor): bool {.inline, noinit.} = self.tensor.dynamicCppCall("is_set_to", tensor.tensor).to(bool)
proc masked_fill_u*(ty: TensorType; self: Tensor, mask: Tensor, value: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("masked_fill_", self.tensor, mask.tensor, value).to(ATensor).newTensor()
proc masked_fill_u*(self: Tensor, mask: Tensor, value: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("masked_fill_", mask.tensor, value).to(ATensor).newTensor()
proc masked_fill_u*(ty: TensorType; self: Tensor, mask: Tensor, value: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("masked_fill_", self.tensor, mask.tensor, value.tensor).to(ATensor).newTensor()
proc masked_fill_u*(self: Tensor, mask: Tensor, value: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("masked_fill_", mask.tensor, value.tensor).to(ATensor).newTensor()
proc masked_scatter_u*(ty: TensorType; self: Tensor, mask: Tensor, source: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("masked_scatter_", self.tensor, mask.tensor, source.tensor).to(ATensor).newTensor()
proc masked_scatter_u*(self: Tensor, mask: Tensor, source: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("masked_scatter_", mask.tensor, source.tensor).to(ATensor).newTensor()
proc masked_select*(ty: TensorType; self: Tensor, mask: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("masked_select", self.tensor, mask.tensor).to(ATensor).newTensor()
proc masked_select*(self: Tensor, mask: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("masked_select", mask.tensor).to(ATensor).newTensor()
proc nonzero*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("nonzero", self.tensor).to(ATensor).newTensor()
proc nonzero*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("nonzero").to(ATensor).newTensor()
proc contiguous*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("contiguous", self.tensor).to(ATensor).newTensor()
proc contiguous*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("contiguous").to(ATensor).newTensor()
proc th_clone*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("th_clone", self.tensor).to(ATensor).newTensor()
proc th_clone*(self: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::th_clone", self.tensor).to(ATensor).newTensor()
proc view*(ty: TensorType; self: Tensor, size: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("view", self.tensor, size).to(ATensor).newTensor()
proc view*(self: Tensor, size: IntList): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("view", size).to(ATensor).newTensor()
proc th_resize_as_u*(ty: TensorType; self: Tensor, the_template: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("th_resize_as_", self.tensor, the_template.tensor).to(ATensor).newTensor()
proc th_resize_as_u*(self: Tensor, the_template: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::th_resize_as_", self.tensor, the_template.tensor).to(ATensor).newTensor()
proc index_select*(ty: TensorType; self: Tensor, dim: int64, index: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("index_select", self.tensor, dim, index.tensor).to(ATensor).newTensor()
proc index_select*(self: Tensor, dim: int64, index: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("index_select", dim, index.tensor).to(ATensor).newTensor()
proc u_indexCopy_u*(ty: TensorType; self: Tensor, dim: int64, index: Tensor, source: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_indexCopy_", self.tensor, dim, index.tensor, source.tensor).to(ATensor).newTensor()
proc u_indexCopy_u*(self: Tensor, dim: int64, index: Tensor, source: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_indexCopy_", dim, index.tensor, source.tensor).to(ATensor).newTensor()
proc take*(ty: TensorType; self: Tensor, index: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("take", self.tensor, index.tensor).to(ATensor).newTensor()
proc take*(self: Tensor, index: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("take", index.tensor).to(ATensor).newTensor()
proc put_u*(ty: TensorType; self: Tensor, index: Tensor, source: Tensor, accumulate: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("put_", self.tensor, index.tensor, source.tensor, accumulate).to(ATensor).newTensor()
proc put_u*(self: Tensor, index: Tensor, source: Tensor, accumulate: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("put_", index.tensor, source.tensor, accumulate).to(ATensor).newTensor()
proc index_add_u*(ty: TensorType; self: Tensor, dim: int64, index: Tensor, source: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("index_add_", self.tensor, dim, index.tensor, source.tensor).to(ATensor).newTensor()
proc index_add_u*(self: Tensor, dim: int64, index: Tensor, source: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("index_add_", dim, index.tensor, source.tensor).to(ATensor).newTensor()
proc index_fill_u*(ty: TensorType; self: Tensor, dim: int64, index: Tensor, value: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("index_fill_", self.tensor, dim, index.tensor, value).to(ATensor).newTensor()
proc index_fill_u*(self: Tensor, dim: int64, index: Tensor, value: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("index_fill_", dim, index.tensor, value).to(ATensor).newTensor()
proc index_fill_u*(ty: TensorType; self: Tensor, dim: int64, index: Tensor, value: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("index_fill_", self.tensor, dim, index.tensor, value.tensor).to(ATensor).newTensor()
proc index_fill_u*(self: Tensor, dim: int64, index: Tensor, value: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("index_fill_", dim, index.tensor, value.tensor).to(ATensor).newTensor()
proc unfold*(ty: TensorType; self: Tensor, dimension: int64, size: int64, step: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("unfold", self.tensor, dimension, size, step).to(ATensor).newTensor()
proc unfold*(self: Tensor, dimension: int64, size: int64, step: int64): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("unfold", dimension, size, step).to(ATensor).newTensor()
proc u_range*(ty: TensorType; start: float, aend: float, step: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("_range", start, aend, step).to(ATensor).newTensor()
proc u_arange*(ty: TensorType; start: float, aend: float, step: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("_arange", start, aend, step).to(ATensor).newTensor()
proc u_arange*(ty: TensorType; aend: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("_arange", aend).to(ATensor).newTensor()
proc scatter_u*(ty: TensorType; self: Tensor, dim: int64, index: Tensor, src: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("scatter_", self.tensor, dim, index.tensor, src.tensor).to(ATensor).newTensor()
proc scatter_u*(self: Tensor, dim: int64, index: Tensor, src: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("scatter_", dim, index.tensor, src.tensor).to(ATensor).newTensor()
proc scatter_u*(ty: TensorType; self: Tensor, dim: int64, index: Tensor, value: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("scatter_", self.tensor, dim, index.tensor, value).to(ATensor).newTensor()
proc scatter_u*(self: Tensor, dim: int64, index: Tensor, value: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("scatter_", dim, index.tensor, value).to(ATensor).newTensor()
proc scatter_add_u*(ty: TensorType; self: Tensor, dim: int64, index: Tensor, src: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("scatter_add_", self.tensor, dim, index.tensor, src.tensor).to(ATensor).newTensor()
proc scatter_add_u*(self: Tensor, dim: int64, index: Tensor, src: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("scatter_add_", dim, index.tensor, src.tensor).to(ATensor).newTensor()
proc gather*(ty: TensorType; self: Tensor, dim: int64, index: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("gather", self.tensor, dim, index.tensor).to(ATensor).newTensor()
proc gather*(self: Tensor, dim: int64, index: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("gather", dim, index.tensor).to(ATensor).newTensor()
proc data_ptr*(ty: TensorType; self: Tensor): pointer {.inline, noinit.} = ty.dynamicCppCall("data_ptr", self.tensor).to(pointer)
proc data_ptr*(self: Tensor): pointer {.inline, noinit.} = self.tensor.dynamicCppCall("data_ptr").to(pointer)
proc equal*(ty: TensorType; self: Tensor, other: Tensor): bool {.inline, noinit.} = ty.dynamicCppCall("equal", self.tensor, other.tensor).to(bool)
proc equal*(self: Tensor, other: Tensor): bool {.inline, noinit.} = self.tensor.dynamicCppCall("equal", other.tensor).to(bool)
proc u_u_uand_u_uu*(ty: TensorType; self: Tensor, other: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("__and__", self.tensor, other).to(ATensor).newTensor()
proc u_u_uand_u_uu*(self: Tensor, other: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("__and__", other).to(ATensor).newTensor()
proc u_u_uand_u_uu*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("__and__", self.tensor, other.tensor).to(ATensor).newTensor()
proc u_u_uand_u_uu*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("__and__", other.tensor).to(ATensor).newTensor()
proc u_u_uiand_u_uu*(ty: TensorType; self: Tensor, other: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("__iand__", self.tensor, other).to(ATensor).newTensor()
proc u_u_uiand_u_uu*(self: Tensor, other: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("__iand__", other).to(ATensor).newTensor()
proc u_u_uiand_u_uu*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("__iand__", self.tensor, other.tensor).to(ATensor).newTensor()
proc u_u_uiand_u_uu*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("__iand__", other.tensor).to(ATensor).newTensor()
proc u_u_uor_u_uu*(ty: TensorType; self: Tensor, other: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("__or__", self.tensor, other).to(ATensor).newTensor()
proc u_u_uor_u_uu*(self: Tensor, other: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("__or__", other).to(ATensor).newTensor()
proc u_u_uor_u_uu*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("__or__", self.tensor, other.tensor).to(ATensor).newTensor()
proc u_u_uor_u_uu*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("__or__", other.tensor).to(ATensor).newTensor()
proc u_u_uior_u_uu*(ty: TensorType; self: Tensor, other: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("__ior__", self.tensor, other).to(ATensor).newTensor()
proc u_u_uior_u_uu*(self: Tensor, other: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("__ior__", other).to(ATensor).newTensor()
proc u_u_uior_u_uu*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("__ior__", self.tensor, other.tensor).to(ATensor).newTensor()
proc u_u_uior_u_uu*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("__ior__", other.tensor).to(ATensor).newTensor()
proc u_u_uxor_u_uu*(ty: TensorType; self: Tensor, other: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("__xor__", self.tensor, other).to(ATensor).newTensor()
proc u_u_uxor_u_uu*(self: Tensor, other: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("__xor__", other).to(ATensor).newTensor()
proc u_u_uxor_u_uu*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("__xor__", self.tensor, other.tensor).to(ATensor).newTensor()
proc u_u_uxor_u_uu*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("__xor__", other.tensor).to(ATensor).newTensor()
proc u_u_uixor_u_uu*(ty: TensorType; self: Tensor, other: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("__ixor__", self.tensor, other).to(ATensor).newTensor()
proc u_u_uixor_u_uu*(self: Tensor, other: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("__ixor__", other).to(ATensor).newTensor()
proc u_u_uixor_u_uu*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("__ixor__", self.tensor, other.tensor).to(ATensor).newTensor()
proc u_u_uixor_u_uu*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("__ixor__", other.tensor).to(ATensor).newTensor()
proc u_u_ulshift_u_uu*(ty: TensorType; self: Tensor, other: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("__lshift__", self.tensor, other).to(ATensor).newTensor()
proc u_u_ulshift_u_uu*(self: Tensor, other: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("__lshift__", other).to(ATensor).newTensor()
proc u_u_ulshift_u_uu*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("__lshift__", self.tensor, other.tensor).to(ATensor).newTensor()
proc u_u_ulshift_u_uu*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("__lshift__", other.tensor).to(ATensor).newTensor()
proc u_u_uilshift_u_uu*(ty: TensorType; self: Tensor, other: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("__ilshift__", self.tensor, other).to(ATensor).newTensor()
proc u_u_uilshift_u_uu*(self: Tensor, other: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("__ilshift__", other).to(ATensor).newTensor()
proc u_u_uilshift_u_uu*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("__ilshift__", self.tensor, other.tensor).to(ATensor).newTensor()
proc u_u_uilshift_u_uu*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("__ilshift__", other.tensor).to(ATensor).newTensor()
proc u_u_urshift_u_uu*(ty: TensorType; self: Tensor, other: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("__rshift__", self.tensor, other).to(ATensor).newTensor()
proc u_u_urshift_u_uu*(self: Tensor, other: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("__rshift__", other).to(ATensor).newTensor()
proc u_u_urshift_u_uu*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("__rshift__", self.tensor, other.tensor).to(ATensor).newTensor()
proc u_u_urshift_u_uu*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("__rshift__", other.tensor).to(ATensor).newTensor()
proc u_u_uirshift_u_uu*(ty: TensorType; self: Tensor, other: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("__irshift__", self.tensor, other).to(ATensor).newTensor()
proc u_u_uirshift_u_uu*(self: Tensor, other: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("__irshift__", other).to(ATensor).newTensor()
proc u_u_uirshift_u_uu*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("__irshift__", self.tensor, other.tensor).to(ATensor).newTensor()
proc u_u_uirshift_u_uu*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("__irshift__", other.tensor).to(ATensor).newTensor()
proc lt*(ty: TensorType; self: Tensor, other: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("lt", self.tensor, other).to(ATensor).newTensor()
proc lt*(self: Tensor, other: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("lt", other).to(ATensor).newTensor()
proc lt*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("lt", self.tensor, other.tensor).to(ATensor).newTensor()
proc lt*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("lt", other.tensor).to(ATensor).newTensor()
proc lt_u*(ty: TensorType; self: Tensor, other: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("lt_", self.tensor, other).to(ATensor).newTensor()
proc lt_u*(self: Tensor, other: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("lt_", other).to(ATensor).newTensor()
proc lt_u*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("lt_", self.tensor, other.tensor).to(ATensor).newTensor()
proc lt_u*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("lt_", other.tensor).to(ATensor).newTensor()
proc gt*(ty: TensorType; self: Tensor, other: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("gt", self.tensor, other).to(ATensor).newTensor()
proc gt*(self: Tensor, other: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("gt", other).to(ATensor).newTensor()
proc gt*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("gt", self.tensor, other.tensor).to(ATensor).newTensor()
proc gt*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("gt", other.tensor).to(ATensor).newTensor()
proc gt_u*(ty: TensorType; self: Tensor, other: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("gt_", self.tensor, other).to(ATensor).newTensor()
proc gt_u*(self: Tensor, other: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("gt_", other).to(ATensor).newTensor()
proc gt_u*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("gt_", self.tensor, other.tensor).to(ATensor).newTensor()
proc gt_u*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("gt_", other.tensor).to(ATensor).newTensor()
proc le*(ty: TensorType; self: Tensor, other: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("le", self.tensor, other).to(ATensor).newTensor()
proc le*(self: Tensor, other: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("le", other).to(ATensor).newTensor()
proc le*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("le", self.tensor, other.tensor).to(ATensor).newTensor()
proc le*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("le", other.tensor).to(ATensor).newTensor()
proc le_u*(ty: TensorType; self: Tensor, other: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("le_", self.tensor, other).to(ATensor).newTensor()
proc le_u*(self: Tensor, other: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("le_", other).to(ATensor).newTensor()
proc le_u*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("le_", self.tensor, other.tensor).to(ATensor).newTensor()
proc le_u*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("le_", other.tensor).to(ATensor).newTensor()
proc ge*(ty: TensorType; self: Tensor, other: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("ge", self.tensor, other).to(ATensor).newTensor()
proc ge*(self: Tensor, other: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("ge", other).to(ATensor).newTensor()
proc ge*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("ge", self.tensor, other.tensor).to(ATensor).newTensor()
proc ge*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("ge", other.tensor).to(ATensor).newTensor()
proc ge_u*(ty: TensorType; self: Tensor, other: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("ge_", self.tensor, other).to(ATensor).newTensor()
proc ge_u*(self: Tensor, other: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("ge_", other).to(ATensor).newTensor()
proc ge_u*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("ge_", self.tensor, other.tensor).to(ATensor).newTensor()
proc ge_u*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("ge_", other.tensor).to(ATensor).newTensor()
proc eq*(ty: TensorType; self: Tensor, other: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("eq", self.tensor, other).to(ATensor).newTensor()
proc eq*(self: Tensor, other: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("eq", other).to(ATensor).newTensor()
proc eq*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("eq", self.tensor, other.tensor).to(ATensor).newTensor()
proc eq*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("eq", other.tensor).to(ATensor).newTensor()
proc eq_u*(ty: TensorType; self: Tensor, other: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("eq_", self.tensor, other).to(ATensor).newTensor()
proc eq_u*(self: Tensor, other: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("eq_", other).to(ATensor).newTensor()
proc eq_u*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("eq_", self.tensor, other.tensor).to(ATensor).newTensor()
proc eq_u*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("eq_", other.tensor).to(ATensor).newTensor()
proc ne*(ty: TensorType; self: Tensor, other: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("ne", self.tensor, other).to(ATensor).newTensor()
proc ne*(self: Tensor, other: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("ne", other).to(ATensor).newTensor()
proc ne*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("ne", self.tensor, other.tensor).to(ATensor).newTensor()
proc ne*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("ne", other.tensor).to(ATensor).newTensor()
proc ne_u*(ty: TensorType; self: Tensor, other: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("ne_", self.tensor, other).to(ATensor).newTensor()
proc ne_u*(self: Tensor, other: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("ne_", other).to(ATensor).newTensor()
proc ne_u*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("ne_", self.tensor, other.tensor).to(ATensor).newTensor()
proc ne_u*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("ne_", other.tensor).to(ATensor).newTensor()
proc min*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("min", self.tensor, other.tensor).to(ATensor).newTensor()
proc min*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("min", other.tensor).to(ATensor).newTensor()
proc min*(ty: TensorType; self: Tensor): float {.inline, noinit.} = ty.dynamicCppCall("min", self.tensor).to(float)
proc min*(self: Tensor): float {.inline, noinit.} = self.tensor.dynamicCppCall("min").to(float)
proc u_th_min*(ty: TensorType; self: Tensor, dim: int64, keepdim: bool = false): tuple[min: Tensor, min_indices: Tensor] {.inline, noinit.} = ty.dynamicCppCall("_th_min", self.tensor, dim, keepdim).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc u_th_min*(self: Tensor, dim: int64, keepdim: bool = false): tuple[min: Tensor, min_indices: Tensor] {.inline, noinit.} = self.tensor.dynamicCppCall("_th_min", dim, keepdim).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc max*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("max", self.tensor, other.tensor).to(ATensor).newTensor()
proc max*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("max", other.tensor).to(ATensor).newTensor()
proc max*(ty: TensorType; self: Tensor): float {.inline, noinit.} = ty.dynamicCppCall("max", self.tensor).to(float)
proc max*(self: Tensor): float {.inline, noinit.} = self.tensor.dynamicCppCall("max").to(float)
proc u_th_max*(ty: TensorType; self: Tensor, dim: int64, keepdim: bool = false): tuple[max: Tensor, max_indices: Tensor] {.inline, noinit.} = ty.dynamicCppCall("_th_max", self.tensor, dim, keepdim).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc u_th_max*(self: Tensor, dim: int64, keepdim: bool = false): tuple[max: Tensor, max_indices: Tensor] {.inline, noinit.} = self.tensor.dynamicCppCall("_th_max", dim, keepdim).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc u_th_kthvalue*(ty: TensorType; self: Tensor, k: int64, dim: int64 = -1, keepdim: bool = false): tuple[values: Tensor, indices: Tensor] {.inline, noinit.} = ty.dynamicCppCall("_th_kthvalue", self.tensor, k, dim, keepdim).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc u_th_kthvalue*(self: Tensor, k: int64, dim: int64 = -1, keepdim: bool = false): tuple[values: Tensor, indices: Tensor] {.inline, noinit.} = self.tensor.dynamicCppCall("_th_kthvalue", k, dim, keepdim).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc u_th_mode*(ty: TensorType; self: Tensor, dim: int64 = -1, keepdim: bool = false): tuple[values: Tensor, indices: Tensor] {.inline, noinit.} = ty.dynamicCppCall("_th_mode", self.tensor, dim, keepdim).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc u_th_mode*(self: Tensor, dim: int64 = -1, keepdim: bool = false): tuple[values: Tensor, indices: Tensor] {.inline, noinit.} = self.tensor.dynamicCppCall("_th_mode", dim, keepdim).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc median*(ty: TensorType; self: Tensor): float {.inline, noinit.} = ty.dynamicCppCall("median", self.tensor).to(float)
proc median*(self: Tensor): float {.inline, noinit.} = self.tensor.dynamicCppCall("median").to(float)
proc u_th_median*(ty: TensorType; self: Tensor, dim: int64, keepdim: bool = false): tuple[values: Tensor, indices: Tensor] {.inline, noinit.} = ty.dynamicCppCall("_th_median", self.tensor, dim, keepdim).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc u_th_median*(self: Tensor, dim: int64, keepdim: bool = false): tuple[values: Tensor, indices: Tensor] {.inline, noinit.} = self.tensor.dynamicCppCall("_th_median", dim, keepdim).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc sort*(ty: TensorType; self: Tensor, dim: int64 = -1, descending: bool = false): tuple[values: Tensor, indices: Tensor] {.inline, noinit.} = ty.dynamicCppCall("sort", self.tensor, dim, descending).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc sort*(self: Tensor, dim: int64 = -1, descending: bool = false): tuple[values: Tensor, indices: Tensor] {.inline, noinit.} = self.tensor.dynamicCppCall("sort", dim, descending).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc topk*(ty: TensorType; self: Tensor, k: int64, dim: int64 = -1, largest: bool = true, sorted: bool = true): tuple[values: Tensor, indices: Tensor] {.inline, noinit.} = ty.dynamicCppCall("topk", self.tensor, k, dim, largest, sorted).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc topk*(self: Tensor, k: int64, dim: int64 = -1, largest: bool = true, sorted: bool = true): tuple[values: Tensor, indices: Tensor] {.inline, noinit.} = self.tensor.dynamicCppCall("topk", k, dim, largest, sorted).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc all*(ty: TensorType; self: Tensor): float {.inline, noinit.} = ty.dynamicCppCall("all", self.tensor).to(float)
proc all*(self: Tensor): float {.inline, noinit.} = self.tensor.dynamicCppCall("all").to(float)
proc u_th_all*(ty: TensorType; self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("_th_all", self.tensor, dim, keepdim).to(ATensor).newTensor()
proc u_th_all*(self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_th_all", dim, keepdim).to(ATensor).newTensor()
proc any*(ty: TensorType; self: Tensor): float {.inline, noinit.} = ty.dynamicCppCall("any", self.tensor).to(float)
proc any*(self: Tensor): float {.inline, noinit.} = self.tensor.dynamicCppCall("any").to(float)
proc u_th_any*(ty: TensorType; self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("_th_any", self.tensor, dim, keepdim).to(ATensor).newTensor()
proc u_th_any*(self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_th_any", dim, keepdim).to(ATensor).newTensor()
proc u_th_get_device*(ty: TensorType; self: Tensor): int64 {.inline, noinit.} = ty.dynamicCppCall("_th_get_device", self.tensor).to(int64)
proc u_th_get_device*(self: Tensor): int64 {.inline, noinit.} = dynamicCCall("at::_th_get_device", self.tensor).to(int64)
proc u_abs*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_abs", self.tensor).to(ATensor).newTensor()
proc u_abs*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_abs").to(ATensor).newTensor()
proc u_th_sigmoid*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_th_sigmoid", self.tensor).to(ATensor).newTensor()
proc u_th_sigmoid*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_th_sigmoid").to(ATensor).newTensor()
proc u_log*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_log", self.tensor).to(ATensor).newTensor()
proc u_log*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_log").to(ATensor).newTensor()
proc u_log10*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_log10", self.tensor).to(ATensor).newTensor()
proc u_log10*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_log10").to(ATensor).newTensor()
proc u_log1p*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_log1p", self.tensor).to(ATensor).newTensor()
proc u_log1p*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_log1p").to(ATensor).newTensor()
proc u_log2*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_log2", self.tensor).to(ATensor).newTensor()
proc u_log2*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_log2").to(ATensor).newTensor()
proc lgamma*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("lgamma", self.tensor).to(ATensor).newTensor()
proc lgamma*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("lgamma").to(ATensor).newTensor()
proc lgamma_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("lgamma_", self.tensor).to(ATensor).newTensor()
proc lgamma_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("lgamma_").to(ATensor).newTensor()
proc digamma*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("digamma", self.tensor).to(ATensor).newTensor()
proc digamma*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("digamma").to(ATensor).newTensor()
proc digamma_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("digamma_", self.tensor).to(ATensor).newTensor()
proc digamma_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("digamma_").to(ATensor).newTensor()
proc polygamma*(ty: TensorType; n: int64, self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("polygamma", n, self.tensor).to(ATensor).newTensor()
proc polygamma*(n: int64, self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("polygamma", n).to(ATensor).newTensor()
proc polygamma_u*(ty: TensorType; self: Tensor, n: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("polygamma_", self.tensor, n).to(ATensor).newTensor()
proc polygamma_u*(self: Tensor, n: int64): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("polygamma_", n).to(ATensor).newTensor()
proc u_exp*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_exp", self.tensor).to(ATensor).newTensor()
proc u_exp*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_exp").to(ATensor).newTensor()
proc u_expm1*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_expm1", self.tensor).to(ATensor).newTensor()
proc u_expm1*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_expm1").to(ATensor).newTensor()
proc u_cos*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_cos", self.tensor).to(ATensor).newTensor()
proc u_cos*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_cos").to(ATensor).newTensor()
proc u_acos*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_acos", self.tensor).to(ATensor).newTensor()
proc u_acos*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_acos").to(ATensor).newTensor()
proc u_cosh*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_cosh", self.tensor).to(ATensor).newTensor()
proc u_cosh*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_cosh").to(ATensor).newTensor()
proc u_sin*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_sin", self.tensor).to(ATensor).newTensor()
proc u_sin*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_sin").to(ATensor).newTensor()
proc u_asin*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_asin", self.tensor).to(ATensor).newTensor()
proc u_asin*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_asin").to(ATensor).newTensor()
proc u_sinh*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_sinh", self.tensor).to(ATensor).newTensor()
proc u_sinh*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_sinh").to(ATensor).newTensor()
proc u_tan*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_tan", self.tensor).to(ATensor).newTensor()
proc u_tan*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_tan").to(ATensor).newTensor()
proc u_atan*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_atan", self.tensor).to(ATensor).newTensor()
proc u_atan*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_atan").to(ATensor).newTensor()
proc u_th_tanh*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_th_tanh", self.tensor).to(ATensor).newTensor()
proc u_th_tanh*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_th_tanh").to(ATensor).newTensor()
proc u_erf*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_erf", self.tensor).to(ATensor).newTensor()
proc u_erf*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_erf").to(ATensor).newTensor()
proc u_erfc*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_erfc", self.tensor).to(ATensor).newTensor()
proc u_erfc*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_erfc").to(ATensor).newTensor()
proc erfinv_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("erfinv_", self.tensor).to(ATensor).newTensor()
proc erfinv_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("erfinv_").to(ATensor).newTensor()
proc erfinv*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("erfinv", self.tensor).to(ATensor).newTensor()
proc erfinv*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("erfinv").to(ATensor).newTensor()
proc u_sqrt*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_sqrt", self.tensor).to(ATensor).newTensor()
proc u_sqrt*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_sqrt").to(ATensor).newTensor()
proc u_rsqrt*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_rsqrt", self.tensor).to(ATensor).newTensor()
proc u_rsqrt*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_rsqrt").to(ATensor).newTensor()
proc u_ceil*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_ceil", self.tensor).to(ATensor).newTensor()
proc u_ceil*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_ceil").to(ATensor).newTensor()
proc u_floor*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_floor", self.tensor).to(ATensor).newTensor()
proc u_floor*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_floor").to(ATensor).newTensor()
proc u_round*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_round", self.tensor).to(ATensor).newTensor()
proc u_round*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_round").to(ATensor).newTensor()
proc u_trunc*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_trunc", self.tensor).to(ATensor).newTensor()
proc u_trunc*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_trunc").to(ATensor).newTensor()
proc frac_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("frac_", self.tensor).to(ATensor).newTensor()
proc frac_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("frac_").to(ATensor).newTensor()
proc frac*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("frac", self.tensor).to(ATensor).newTensor()
proc frac*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("frac").to(ATensor).newTensor()
proc u_th_var*(ty: TensorType; self: Tensor, dim: int64, unbiased: bool = true, keepdim: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("_th_var", self.tensor, dim, unbiased, keepdim).to(ATensor).newTensor()
proc u_th_var*(self: Tensor, dim: int64, unbiased: bool = true, keepdim: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_th_var", dim, unbiased, keepdim).to(ATensor).newTensor()
proc u_th_var*(ty: TensorType; self: Tensor, unbiased: bool = true): float {.inline, noinit.} = ty.dynamicCppCall("_th_var", self.tensor, unbiased).to(float)
proc u_th_var*(self: Tensor, unbiased: bool = true): float {.inline, noinit.} = self.tensor.dynamicCppCall("_th_var", unbiased).to(float)
proc u_th_std*(ty: TensorType; self: Tensor, dim: int64, unbiased: bool = true, keepdim: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("_th_std", self.tensor, dim, unbiased, keepdim).to(ATensor).newTensor()
proc u_th_std*(self: Tensor, dim: int64, unbiased: bool = true, keepdim: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_th_std", dim, unbiased, keepdim).to(ATensor).newTensor()
proc u_th_std*(ty: TensorType; self: Tensor, unbiased: bool = true): float {.inline, noinit.} = ty.dynamicCppCall("_th_std", self.tensor, unbiased).to(float)
proc u_th_std*(self: Tensor, unbiased: bool = true): float {.inline, noinit.} = self.tensor.dynamicCppCall("_th_std", unbiased).to(float)
proc th_norm*(ty: TensorType; self: Tensor, p: float = 2): float {.inline, noinit.} = ty.dynamicCppCall("th_norm", self.tensor, p).to(float)
proc th_norm*(self: Tensor, p: float = 2): float {.inline, noinit.} = dynamicCCall("at::th_norm", self.tensor, p).to(float)
proc u_th_norm*(ty: TensorType; self: Tensor, p: float, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("_th_norm", self.tensor, p, dim, keepdim).to(ATensor).newTensor()
proc u_th_norm*(self: Tensor, p: float, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_th_norm", p, dim, keepdim).to(ATensor).newTensor()
proc renorm*(ty: TensorType; self: Tensor, p: float, dim: int64, maxnorm: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("renorm", self.tensor, p, dim, maxnorm).to(ATensor).newTensor()
proc renorm*(self: Tensor, p: float, dim: int64, maxnorm: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("renorm", p, dim, maxnorm).to(ATensor).newTensor()
proc renorm_u*(ty: TensorType; self: Tensor, p: float, dim: int64, maxnorm: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("renorm_", self.tensor, p, dim, maxnorm).to(ATensor).newTensor()
proc renorm_u*(self: Tensor, p: float, dim: int64, maxnorm: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("renorm_", p, dim, maxnorm).to(ATensor).newTensor()
proc dist*(ty: TensorType; self: Tensor, other: Tensor, p: float = 2): float {.inline, noinit.} = ty.dynamicCppCall("dist", self.tensor, other.tensor, p).to(float)
proc dist*(self: Tensor, other: Tensor, p: float = 2): float {.inline, noinit.} = self.tensor.dynamicCppCall("dist", other.tensor, p).to(float)
proc reciprocal*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("reciprocal", self.tensor).to(ATensor).newTensor()
proc reciprocal*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("reciprocal").to(ATensor).newTensor()
proc reciprocal_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("reciprocal_", self.tensor).to(ATensor).newTensor()
proc reciprocal_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("reciprocal_").to(ATensor).newTensor()
proc neg*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("neg", self.tensor).to(ATensor).newTensor()
proc neg*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("neg").to(ATensor).newTensor()
proc neg_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("neg_", self.tensor).to(ATensor).newTensor()
proc neg_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("neg_").to(ATensor).newTensor()
proc atan2*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("atan2", self.tensor, other.tensor).to(ATensor).newTensor()
proc atan2*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("atan2", other.tensor).to(ATensor).newTensor()
proc atan2_u*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("atan2_", self.tensor, other.tensor).to(ATensor).newTensor()
proc atan2_u*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("atan2_", other.tensor).to(ATensor).newTensor()
proc th_pow*(ty: TensorType; self: Tensor, exponent: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("th_pow", self.tensor, exponent).to(ATensor).newTensor()
proc th_pow*(self: Tensor, exponent: float): Tensor {.inline, noinit.} = dynamicCCall("at::th_pow", self.tensor, exponent).to(ATensor).newTensor()
proc pow*(ty: TensorType; self: Tensor, exponent: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("pow", self.tensor, exponent.tensor).to(ATensor).newTensor()
proc pow*(self: Tensor, exponent: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("pow", exponent.tensor).to(ATensor).newTensor()
proc pow*(ty: TensorType; base: float, self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("pow", base, self.tensor).to(ATensor).newTensor()
proc pow*(base: float, self: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::pow", base, self.tensor).to(ATensor).newTensor()
proc pow_u*(ty: TensorType; self: Tensor, exponent: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("pow_", self.tensor, exponent).to(ATensor).newTensor()
proc pow_u*(self: Tensor, exponent: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("pow_", exponent).to(ATensor).newTensor()
proc pow_u*(ty: TensorType; self: Tensor, exponent: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("pow_", self.tensor, exponent.tensor).to(ATensor).newTensor()
proc pow_u*(self: Tensor, exponent: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("pow_", exponent.tensor).to(ATensor).newTensor()
proc lerp*(ty: TensorType; self: Tensor, aend: Tensor, weight: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("lerp", self.tensor, aend.tensor, weight).to(ATensor).newTensor()
proc lerp*(self: Tensor, aend: Tensor, weight: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("lerp", aend.tensor, weight).to(ATensor).newTensor()
proc lerp_u*(ty: TensorType; self: Tensor, aend: Tensor, weight: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("lerp_", self.tensor, aend.tensor, weight).to(ATensor).newTensor()
proc lerp_u*(self: Tensor, aend: Tensor, weight: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("lerp_", aend.tensor, weight).to(ATensor).newTensor()
proc u_linspace*(ty: TensorType; start: float, aend: float, steps: int64 = 100): Tensor {.inline, noinit.} = ty.dynamicCppCall("_linspace", start, aend, steps).to(ATensor).newTensor()
proc u_logspace*(ty: TensorType; start: float, aend: float, steps: int64 = 100): Tensor {.inline, noinit.} = ty.dynamicCppCall("_logspace", start, aend, steps).to(ATensor).newTensor()
proc histc*(ty: TensorType; self: Tensor, bins: int64 = 100, min: float = 0, max: float = 0): Tensor {.inline, noinit.} = ty.dynamicCppCall("histc", self.tensor, bins, min, max).to(ATensor).newTensor()
proc histc*(self: Tensor, bins: int64 = 100, min: float = 0, max: float = 0): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("histc", bins, min, max).to(ATensor).newTensor()
proc th_zero_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("th_zero_", self.tensor).to(ATensor).newTensor()
proc th_zero_u*(self: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::th_zero_", self.tensor).to(ATensor).newTensor()
proc u_sumall*(ty: TensorType; self: Tensor): float {.inline, noinit.} = ty.dynamicCppCall("_sumall", self.tensor).to(float)
proc u_sumall*(self: Tensor): float {.inline, noinit.} = self.tensor.dynamicCppCall("_sumall").to(float)
proc u_th_sum*(ty: TensorType; self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("_th_sum", self.tensor, dim, keepdim).to(ATensor).newTensor()
proc u_th_sum*(self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_th_sum", dim, keepdim).to(ATensor).newTensor()
proc u_prodall*(ty: TensorType; self: Tensor): float {.inline, noinit.} = ty.dynamicCppCall("_prodall", self.tensor).to(float)
proc u_prodall*(self: Tensor): float {.inline, noinit.} = self.tensor.dynamicCppCall("_prodall").to(float)
proc u_th_prod*(ty: TensorType; self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("_th_prod", self.tensor, dim, keepdim).to(ATensor).newTensor()
proc u_th_prod*(self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_th_prod", dim, keepdim).to(ATensor).newTensor()
proc u_cumsum*(ty: TensorType; self: Tensor, dim: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("_cumsum", self.tensor, dim).to(ATensor).newTensor()
proc u_cumsum*(self: Tensor, dim: int64): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_cumsum", dim).to(ATensor).newTensor()
proc u_cumprod*(ty: TensorType; self: Tensor, dim: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("_cumprod", self.tensor, dim).to(ATensor).newTensor()
proc u_cumprod*(self: Tensor, dim: int64): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_cumprod", dim).to(ATensor).newTensor()
proc sign*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("sign", self.tensor).to(ATensor).newTensor()
proc sign*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("sign").to(ATensor).newTensor()
proc sign_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("sign_", self.tensor).to(ATensor).newTensor()
proc sign_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("sign_").to(ATensor).newTensor()
proc trace*(ty: TensorType; self: Tensor): float {.inline, noinit.} = ty.dynamicCppCall("trace", self.tensor).to(float)
proc trace*(self: Tensor): float {.inline, noinit.} = self.tensor.dynamicCppCall("trace").to(float)
proc fmod*(ty: TensorType; self: Tensor, other: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("fmod", self.tensor, other).to(ATensor).newTensor()
proc fmod*(self: Tensor, other: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("fmod", other).to(ATensor).newTensor()
proc fmod*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("fmod", self.tensor, other.tensor).to(ATensor).newTensor()
proc fmod*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("fmod", other.tensor).to(ATensor).newTensor()
proc fmod_u*(ty: TensorType; self: Tensor, other: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("fmod_", self.tensor, other).to(ATensor).newTensor()
proc fmod_u*(self: Tensor, other: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("fmod_", other).to(ATensor).newTensor()
proc fmod_u*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("fmod_", self.tensor, other.tensor).to(ATensor).newTensor()
proc fmod_u*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("fmod_", other.tensor).to(ATensor).newTensor()
proc remainder*(ty: TensorType; self: Tensor, other: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("remainder", self.tensor, other).to(ATensor).newTensor()
proc remainder*(self: Tensor, other: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("remainder", other).to(ATensor).newTensor()
proc remainder*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("remainder", self.tensor, other.tensor).to(ATensor).newTensor()
proc remainder*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("remainder", other.tensor).to(ATensor).newTensor()
proc remainder_u*(ty: TensorType; self: Tensor, other: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("remainder_", self.tensor, other).to(ATensor).newTensor()
proc remainder_u*(self: Tensor, other: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("remainder_", other).to(ATensor).newTensor()
proc remainder_u*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("remainder_", self.tensor, other.tensor).to(ATensor).newTensor()
proc remainder_u*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("remainder_", other.tensor).to(ATensor).newTensor()
proc u_th_clamp*(ty: TensorType; self: Tensor, min: float, max: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("_th_clamp", self.tensor, min, max).to(ATensor).newTensor()
proc u_th_clamp*(self: Tensor, min: float, max: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_th_clamp", min, max).to(ATensor).newTensor()
proc u_th_clamp_min*(ty: TensorType; self: Tensor, min: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("_th_clamp_min", self.tensor, min).to(ATensor).newTensor()
proc u_th_clamp_min*(self: Tensor, min: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_th_clamp_min", min).to(ATensor).newTensor()
proc u_th_clamp_max*(ty: TensorType; self: Tensor, max: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("_th_clamp_max", self.tensor, max).to(ATensor).newTensor()
proc u_th_clamp_max*(self: Tensor, max: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_th_clamp_max", max).to(ATensor).newTensor()
proc u_dot*(ty: TensorType; self: Tensor, tensor: Tensor): float {.inline, noinit.} = ty.dynamicCppCall("_dot", self.tensor, tensor.tensor).to(float)
proc u_dot*(self: Tensor, tensor: Tensor): float {.inline, noinit.} = self.tensor.dynamicCppCall("_dot", tensor.tensor).to(float)
proc tril*(ty: TensorType; self: Tensor, diagonal: int64 = 0): Tensor {.inline, noinit.} = ty.dynamicCppCall("tril", self.tensor, diagonal).to(ATensor).newTensor()
proc tril*(self: Tensor, diagonal: int64 = 0): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("tril", diagonal).to(ATensor).newTensor()
proc tril_u*(ty: TensorType; self: Tensor, diagonal: int64 = 0): Tensor {.inline, noinit.} = ty.dynamicCppCall("tril_", self.tensor, diagonal).to(ATensor).newTensor()
proc tril_u*(self: Tensor, diagonal: int64 = 0): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("tril_", diagonal).to(ATensor).newTensor()
proc triu*(ty: TensorType; self: Tensor, diagonal: int64 = 0): Tensor {.inline, noinit.} = ty.dynamicCppCall("triu", self.tensor, diagonal).to(ATensor).newTensor()
proc triu*(self: Tensor, diagonal: int64 = 0): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("triu", diagonal).to(ATensor).newTensor()
proc triu_u*(ty: TensorType; self: Tensor, diagonal: int64 = 0): Tensor {.inline, noinit.} = ty.dynamicCppCall("triu_", self.tensor, diagonal).to(ATensor).newTensor()
proc triu_u*(self: Tensor, diagonal: int64 = 0): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("triu_", diagonal).to(ATensor).newTensor()
proc cross*(ty: TensorType; self: Tensor, other: Tensor, dim: int64 = -1): Tensor {.inline, noinit.} = ty.dynamicCppCall("cross", self.tensor, other.tensor, dim).to(ATensor).newTensor()
proc cross*(self: Tensor, other: Tensor, dim: int64 = -1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("cross", other.tensor, dim).to(ATensor).newTensor()
proc diag*(ty: TensorType; self: Tensor, diagonal: int64 = 0): Tensor {.inline, noinit.} = ty.dynamicCppCall("diag", self.tensor, diagonal).to(ATensor).newTensor()
proc diag*(self: Tensor, diagonal: int64 = 0): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("diag", diagonal).to(ATensor).newTensor()
proc th_addmm*(ty: TensorType; self: Tensor, mat1: Tensor, mat2: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("th_addmm", self.tensor, mat1.tensor, mat2.tensor, beta, alpha).to(ATensor).newTensor()
proc th_addmm*(self: Tensor, mat1: Tensor, mat2: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = dynamicCCall("at::th_addmm", self.tensor, mat1.tensor, mat2.tensor, beta, alpha).to(ATensor).newTensor()
proc th_addmm_u*(ty: TensorType; self: Tensor, mat1: Tensor, mat2: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("th_addmm_", self.tensor, mat1.tensor, mat2.tensor, beta, alpha).to(ATensor).newTensor()
proc th_addmm_u*(self: Tensor, mat1: Tensor, mat2: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = dynamicCCall("at::th_addmm_", self.tensor, mat1.tensor, mat2.tensor, beta, alpha).to(ATensor).newTensor()
proc u_addmv*(ty: TensorType; self: Tensor, mat: Tensor, vec: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("_addmv", self.tensor, mat.tensor, vec.tensor, beta, alpha).to(ATensor).newTensor()
proc u_addmv*(self: Tensor, mat: Tensor, vec: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_addmv", mat.tensor, vec.tensor, beta, alpha).to(ATensor).newTensor()
proc u_addmv_u*(ty: TensorType; self: Tensor, mat: Tensor, vec: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("_addmv_", self.tensor, mat.tensor, vec.tensor, beta, alpha).to(ATensor).newTensor()
proc u_addmv_u*(self: Tensor, mat: Tensor, vec: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_addmv_", mat.tensor, vec.tensor, beta, alpha).to(ATensor).newTensor()
proc u_addr*(ty: TensorType; self: Tensor, vec1: Tensor, vec2: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("_addr", self.tensor, vec1.tensor, vec2.tensor, beta, alpha).to(ATensor).newTensor()
proc u_addr*(self: Tensor, vec1: Tensor, vec2: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_addr", vec1.tensor, vec2.tensor, beta, alpha).to(ATensor).newTensor()
proc u_addr_u*(ty: TensorType; self: Tensor, vec1: Tensor, vec2: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("_addr_", self.tensor, vec1.tensor, vec2.tensor, beta, alpha).to(ATensor).newTensor()
proc u_addr_u*(self: Tensor, vec1: Tensor, vec2: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_addr_", vec1.tensor, vec2.tensor, beta, alpha).to(ATensor).newTensor()
proc u_ger*(ty: TensorType; self: Tensor, vec2: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_ger", self.tensor, vec2.tensor).to(ATensor).newTensor()
proc u_ger*(self: Tensor, vec2: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_ger", vec2.tensor).to(ATensor).newTensor()
proc u_mv*(ty: TensorType; self: Tensor, vec: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_mv", self.tensor, vec.tensor).to(ATensor).newTensor()
proc u_mv*(self: Tensor, vec: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_mv", vec.tensor).to(ATensor).newTensor()
proc u_mm*(ty: TensorType; self: Tensor, mat2: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_mm", self.tensor, mat2.tensor).to(ATensor).newTensor()
proc u_mm*(self: Tensor, mat2: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_mm", mat2.tensor).to(ATensor).newTensor()
proc bmm*(ty: TensorType; self: Tensor, mat2: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("bmm", self.tensor, mat2.tensor).to(ATensor).newTensor()
proc bmm*(self: Tensor, mat2: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("bmm", mat2.tensor).to(ATensor).newTensor()
proc addbmm*(ty: TensorType; self: Tensor, batch1: Tensor, batch2: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("addbmm", self.tensor, batch1.tensor, batch2.tensor, beta, alpha).to(ATensor).newTensor()
proc addbmm*(self: Tensor, batch1: Tensor, batch2: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("addbmm", batch1.tensor, batch2.tensor, beta, alpha).to(ATensor).newTensor()
proc addbmm_u*(ty: TensorType; self: Tensor, batch1: Tensor, batch2: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("addbmm_", self.tensor, batch1.tensor, batch2.tensor, beta, alpha).to(ATensor).newTensor()
proc addbmm_u*(self: Tensor, batch1: Tensor, batch2: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("addbmm_", batch1.tensor, batch2.tensor, beta, alpha).to(ATensor).newTensor()
proc baddbmm*(ty: TensorType; self: Tensor, batch1: Tensor, batch2: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("baddbmm", self.tensor, batch1.tensor, batch2.tensor, beta, alpha).to(ATensor).newTensor()
proc baddbmm*(self: Tensor, batch1: Tensor, batch2: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("baddbmm", batch1.tensor, batch2.tensor, beta, alpha).to(ATensor).newTensor()
proc baddbmm_u*(ty: TensorType; self: Tensor, batch1: Tensor, batch2: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("baddbmm_", self.tensor, batch1.tensor, batch2.tensor, beta, alpha).to(ATensor).newTensor()
proc baddbmm_u*(self: Tensor, batch1: Tensor, batch2: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("baddbmm_", batch1.tensor, batch2.tensor, beta, alpha).to(ATensor).newTensor()
proc addcmul*(ty: TensorType; self: Tensor, tensor1: Tensor, tensor2: Tensor, value: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("addcmul", self.tensor, tensor1.tensor, tensor2.tensor, value).to(ATensor).newTensor()
proc addcmul*(self: Tensor, tensor1: Tensor, tensor2: Tensor, value: float = 1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("addcmul", tensor1.tensor, tensor2.tensor, value).to(ATensor).newTensor()
proc addcmul_u*(ty: TensorType; self: Tensor, tensor1: Tensor, tensor2: Tensor, value: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("addcmul_", self.tensor, tensor1.tensor, tensor2.tensor, value).to(ATensor).newTensor()
proc addcmul_u*(self: Tensor, tensor1: Tensor, tensor2: Tensor, value: float = 1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("addcmul_", tensor1.tensor, tensor2.tensor, value).to(ATensor).newTensor()
proc addcdiv*(ty: TensorType; self: Tensor, tensor1: Tensor, tensor2: Tensor, value: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("addcdiv", self.tensor, tensor1.tensor, tensor2.tensor, value).to(ATensor).newTensor()
proc addcdiv*(self: Tensor, tensor1: Tensor, tensor2: Tensor, value: float = 1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("addcdiv", tensor1.tensor, tensor2.tensor, value).to(ATensor).newTensor()
proc addcdiv_u*(ty: TensorType; self: Tensor, tensor1: Tensor, tensor2: Tensor, value: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("addcdiv_", self.tensor, tensor1.tensor, tensor2.tensor, value).to(ATensor).newTensor()
proc addcdiv_u*(self: Tensor, tensor1: Tensor, tensor2: Tensor, value: float = 1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("addcdiv_", tensor1.tensor, tensor2.tensor, value).to(ATensor).newTensor()
proc u_gesv_single*(ty: TensorType; self: Tensor, A: Tensor): tuple[solution: Tensor, lu: Tensor] {.inline, noinit.} = ty.dynamicCppCall("_gesv_single", self.tensor, A.tensor).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc u_gesv_single*(self: Tensor, A: Tensor): tuple[solution: Tensor, lu: Tensor] {.inline, noinit.} = self.tensor.dynamicCppCall("_gesv_single", A.tensor).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc gels*(ty: TensorType; self: Tensor, A: Tensor): tuple[res1: Tensor, res2: Tensor] {.inline, noinit.} = ty.dynamicCppCall("gels", self.tensor, A.tensor).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc gels*(self: Tensor, A: Tensor): tuple[res1: Tensor, res2: Tensor] {.inline, noinit.} = self.tensor.dynamicCppCall("gels", A.tensor).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc trtrs*(ty: TensorType; self: Tensor, A: Tensor, upper: bool = true, transpose: bool = false, unitriangular: bool = false): tuple[res1: Tensor, res2: Tensor] {.inline, noinit.} = ty.dynamicCppCall("trtrs", self.tensor, A.tensor, upper, transpose, unitriangular).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc trtrs*(self: Tensor, A: Tensor, upper: bool = true, transpose: bool = false, unitriangular: bool = false): tuple[res1: Tensor, res2: Tensor] {.inline, noinit.} = self.tensor.dynamicCppCall("trtrs", A.tensor, upper, transpose, unitriangular).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc symeig*(ty: TensorType; self: Tensor, eigenvectors: bool = false, upper: bool = true): tuple[res1: Tensor, res2: Tensor] {.inline, noinit.} = ty.dynamicCppCall("symeig", self.tensor, eigenvectors, upper).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc symeig*(self: Tensor, eigenvectors: bool = false, upper: bool = true): tuple[res1: Tensor, res2: Tensor] {.inline, noinit.} = self.tensor.dynamicCppCall("symeig", eigenvectors, upper).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc eig*(ty: TensorType; self: Tensor, eigenvectors: bool = false): tuple[res1: Tensor, res2: Tensor] {.inline, noinit.} = ty.dynamicCppCall("eig", self.tensor, eigenvectors).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc eig*(self: Tensor, eigenvectors: bool = false): tuple[res1: Tensor, res2: Tensor] {.inline, noinit.} = self.tensor.dynamicCppCall("eig", eigenvectors).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc svd*(ty: TensorType; self: Tensor, some: bool = true): tuple[res1: Tensor, res2: Tensor, res3: Tensor] {.inline, noinit.} = ty.dynamicCppCall("svd", self.tensor, some).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc svd*(self: Tensor, some: bool = true): tuple[res1: Tensor, res2: Tensor, res3: Tensor] {.inline, noinit.} = self.tensor.dynamicCppCall("svd", some).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc u_getri*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_getri", self.tensor).to(ATensor).newTensor()
proc u_getri*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_getri").to(ATensor).newTensor()
proc potrf*(ty: TensorType; self: Tensor, upper: bool = true): Tensor {.inline, noinit.} = ty.dynamicCppCall("potrf", self.tensor, upper).to(ATensor).newTensor()
proc potrf*(self: Tensor, upper: bool = true): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("potrf", upper).to(ATensor).newTensor()
proc potrs*(ty: TensorType; self: Tensor, input2: Tensor, upper: bool = true): Tensor {.inline, noinit.} = ty.dynamicCppCall("potrs", self.tensor, input2.tensor, upper).to(ATensor).newTensor()
proc potrs*(self: Tensor, input2: Tensor, upper: bool = true): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("potrs", input2.tensor, upper).to(ATensor).newTensor()
proc potri*(ty: TensorType; self: Tensor, upper: bool = true): Tensor {.inline, noinit.} = ty.dynamicCppCall("potri", self.tensor, upper).to(ATensor).newTensor()
proc potri*(self: Tensor, upper: bool = true): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("potri", upper).to(ATensor).newTensor()
proc pstrf*(ty: TensorType; self: Tensor, upper: bool = true, tol: float = -1): tuple[res1: Tensor, res2: Tensor] {.inline, noinit.} = ty.dynamicCppCall("pstrf", self.tensor, upper, tol).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc pstrf*(self: Tensor, upper: bool = true, tol: float = -1): tuple[res1: Tensor, res2: Tensor] {.inline, noinit.} = self.tensor.dynamicCppCall("pstrf", upper, tol).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc qr*(ty: TensorType; self: Tensor): tuple[res1: Tensor, res2: Tensor] {.inline, noinit.} = ty.dynamicCppCall("qr", self.tensor).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc qr*(self: Tensor): tuple[res1: Tensor, res2: Tensor] {.inline, noinit.} = self.tensor.dynamicCppCall("qr").to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc geqrf*(ty: TensorType; self: Tensor): tuple[res1: Tensor, res2: Tensor] {.inline, noinit.} = ty.dynamicCppCall("geqrf", self.tensor).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc geqrf*(self: Tensor): tuple[res1: Tensor, res2: Tensor] {.inline, noinit.} = self.tensor.dynamicCppCall("geqrf").to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc orgqr*(ty: TensorType; self: Tensor, input2: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("orgqr", self.tensor, input2.tensor).to(ATensor).newTensor()
proc orgqr*(self: Tensor, input2: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("orgqr", input2.tensor).to(ATensor).newTensor()
proc ormqr*(ty: TensorType; self: Tensor, input2: Tensor, input3: Tensor, left: bool = true, transpose: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("ormqr", self.tensor, input2.tensor, input3.tensor, left, transpose).to(ATensor).newTensor()
proc ormqr*(self: Tensor, input2: Tensor, input3: Tensor, left: bool = true, transpose: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("ormqr", input2.tensor, input3.tensor, left, transpose).to(ATensor).newTensor()
proc btrifact*(ty: TensorType; self: Tensor, pivot: bool = true): tuple[aresult: Tensor, pivots: Tensor] {.inline, noinit.} = ty.dynamicCppCall("btrifact", self.tensor, pivot).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc btrifact*(self: Tensor, pivot: bool = true): tuple[aresult: Tensor, pivots: Tensor] {.inline, noinit.} = self.tensor.dynamicCppCall("btrifact", pivot).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc btrifact_with_info*(ty: TensorType; self: Tensor, pivot: bool = true): tuple[aresult: Tensor, pivots: Tensor, info: Tensor] {.inline, noinit.} = ty.dynamicCppCall("btrifact_with_info", self.tensor, pivot).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc btrifact_with_info*(self: Tensor, pivot: bool = true): tuple[aresult: Tensor, pivots: Tensor, info: Tensor] {.inline, noinit.} = self.tensor.dynamicCppCall("btrifact_with_info", pivot).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc btrisolve*(ty: TensorType; self: Tensor, LU_data: Tensor, LU_pivots: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("btrisolve", self.tensor, LU_data.tensor, LU_pivots.tensor).to(ATensor).newTensor()
proc btrisolve*(self: Tensor, LU_data: Tensor, LU_pivots: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("btrisolve", LU_data.tensor, LU_pivots.tensor).to(ATensor).newTensor()
proc random_u*(ty: TensorType; self: Tensor, afrom: int64, ato: int64, generator: pointer = nil): Tensor {.inline, noinit.} = ty.dynamicCppCall("random_", self.tensor, afrom, ato, generator).to(ATensor).newTensor()
proc random_u*(self: Tensor, afrom: int64, ato: int64, generator: pointer = nil): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("random_", afrom, ato, generator).to(ATensor).newTensor()
proc random_u*(ty: TensorType; self: Tensor, ato: int64, generator: pointer = nil): Tensor {.inline, noinit.} = ty.dynamicCppCall("random_", self.tensor, ato, generator).to(ATensor).newTensor()
proc random_u*(self: Tensor, ato: int64, generator: pointer = nil): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("random_", ato, generator).to(ATensor).newTensor()
proc random_u*(ty: TensorType; self: Tensor, generator: pointer = nil): Tensor {.inline, noinit.} = ty.dynamicCppCall("random_", self.tensor, generator).to(ATensor).newTensor()
proc random_u*(self: Tensor, generator: pointer = nil): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("random_", generator).to(ATensor).newTensor()
proc multinomial*(ty: TensorType; self: Tensor, num_samples: int64, replacement: bool = false, generator: pointer = nil): Tensor {.inline, noinit.} = ty.dynamicCppCall("multinomial", self.tensor, num_samples, replacement, generator).to(ATensor).newTensor()
proc multinomial*(self: Tensor, num_samples: int64, replacement: bool = false, generator: pointer = nil): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("multinomial", num_samples, replacement, generator).to(ATensor).newTensor()
proc uniform_u*(ty: TensorType; self: Tensor, afrom: float64 = 0, ato: float64 = 1, generator: pointer = nil): Tensor {.inline, noinit.} = ty.dynamicCppCall("uniform_", self.tensor, afrom, ato, generator).to(ATensor).newTensor()
proc uniform_u*(self: Tensor, afrom: float64 = 0, ato: float64 = 1, generator: pointer = nil): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("uniform_", afrom, ato, generator).to(ATensor).newTensor()
proc normal*(ty: TensorType; mean: Tensor, std: float64 = 1, generator: pointer = nil): Tensor {.inline, noinit.} = ty.dynamicCppCall("normal", mean.tensor, std, generator).to(ATensor).newTensor()
proc normal*(mean: Tensor, std: float64 = 1, generator: pointer = nil): Tensor {.inline, noinit.} = dynamicCCall("at::normal", mean.tensor, std, generator).to(ATensor).newTensor()
proc normal*(ty: TensorType; mean: float64, std: Tensor, generator: pointer = nil): Tensor {.inline, noinit.} = ty.dynamicCppCall("normal", mean, std.tensor, generator).to(ATensor).newTensor()
proc normal*(mean: float64, std: Tensor, generator: pointer = nil): Tensor {.inline, noinit.} = dynamicCCall("at::normal", mean, std.tensor, generator).to(ATensor).newTensor()
proc normal*(ty: TensorType; mean: Tensor, std: Tensor, generator: pointer = nil): Tensor {.inline, noinit.} = ty.dynamicCppCall("normal", mean.tensor, std.tensor, generator).to(ATensor).newTensor()
proc normal*(mean: Tensor, std: Tensor, generator: pointer = nil): Tensor {.inline, noinit.} = dynamicCCall("at::normal", mean.tensor, std.tensor, generator).to(ATensor).newTensor()
proc normal_u*(ty: TensorType; self: Tensor, mean: float64 = 0, std: float64 = 1, generator: pointer = nil): Tensor {.inline, noinit.} = ty.dynamicCppCall("normal_", self.tensor, mean, std, generator).to(ATensor).newTensor()
proc normal_u*(self: Tensor, mean: float64 = 0, std: float64 = 1, generator: pointer = nil): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("normal_", mean, std, generator).to(ATensor).newTensor()
proc cauchy_u*(ty: TensorType; self: Tensor, median: float64 = 0, sigma: float64 = 1, generator: pointer = nil): Tensor {.inline, noinit.} = ty.dynamicCppCall("cauchy_", self.tensor, median, sigma, generator).to(ATensor).newTensor()
proc cauchy_u*(self: Tensor, median: float64 = 0, sigma: float64 = 1, generator: pointer = nil): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("cauchy_", median, sigma, generator).to(ATensor).newTensor()
proc log_normal_u*(ty: TensorType; self: Tensor, mean: float64 = 1, std: float64 = 2, generator: pointer = nil): Tensor {.inline, noinit.} = ty.dynamicCppCall("log_normal_", self.tensor, mean, std, generator).to(ATensor).newTensor()
proc log_normal_u*(self: Tensor, mean: float64 = 1, std: float64 = 2, generator: pointer = nil): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("log_normal_", mean, std, generator).to(ATensor).newTensor()
proc exponential_u*(ty: TensorType; self: Tensor, lambd: float64 = 1, generator: pointer = nil): Tensor {.inline, noinit.} = ty.dynamicCppCall("exponential_", self.tensor, lambd, generator).to(ATensor).newTensor()
proc exponential_u*(self: Tensor, lambd: float64 = 1, generator: pointer = nil): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("exponential_", lambd, generator).to(ATensor).newTensor()
proc geometric_u*(ty: TensorType; self: Tensor, p: float64, generator: pointer = nil): Tensor {.inline, noinit.} = ty.dynamicCppCall("geometric_", self.tensor, p, generator).to(ATensor).newTensor()
proc geometric_u*(self: Tensor, p: float64, generator: pointer = nil): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("geometric_", p, generator).to(ATensor).newTensor()
proc u_bernoulli_u*(ty: TensorType; self: Tensor, p: float64, generator: pointer = nil): Tensor {.inline, noinit.} = ty.dynamicCppCall("_bernoulli_", self.tensor, p, generator).to(ATensor).newTensor()
proc u_bernoulli_u*(self: Tensor, p: float64, generator: pointer = nil): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_bernoulli_", p, generator).to(ATensor).newTensor()
proc u_th_bernoulli*(ty: TensorType; self: Tensor, generator: pointer = nil): Tensor {.inline, noinit.} = ty.dynamicCppCall("_th_bernoulli", self.tensor, generator).to(ATensor).newTensor()
proc u_th_bernoulli*(self: Tensor, generator: pointer = nil): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_th_bernoulli", generator).to(ATensor).newTensor()
proc u_dirichlet_grad*(ty: TensorType; x: Tensor, alpha: Tensor, total: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_dirichlet_grad", x.tensor, alpha.tensor, total.tensor).to(ATensor).newTensor()
proc u_dirichlet_grad*(x: Tensor, alpha: Tensor, total: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::_dirichlet_grad", x.tensor, alpha.tensor, total.tensor).to(ATensor).newTensor()
proc th_tensor*(ty: TensorType; size: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("th_tensor", size).to(ATensor).newTensor()
proc th_tensor*(ty: TensorType; ): Tensor {.inline, noinit.} = ty.dynamicCppCall("th_tensor").to(ATensor).newTensor()
proc tensor*(ty: TensorType; storage: AStorage, storageOffset: int64, size: IntList, stride: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("tensor", storage, storageOffset, size, stride).to(ATensor).newTensor()
proc tensor*(ty: TensorType; size: IntList, stride: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("tensor", size, stride).to(ATensor).newTensor()
proc alias*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("alias", self.tensor).to(ATensor).newTensor()
proc alias*(self: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::alias", self.tensor).to(ATensor).newTensor()
proc u_copy_ignoring_overlaps_u*(ty: TensorType; self: Tensor, src: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_copy_ignoring_overlaps_", self.tensor, src.tensor).to(ATensor).newTensor()
proc u_copy_ignoring_overlaps_u*(self: Tensor, src: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_copy_ignoring_overlaps_", src.tensor).to(ATensor).newTensor()
proc u_cat*(ty: TensorType; tensors: TensorList, dim: int64 = 0): Tensor {.inline, noinit.} = ty.dynamicCppCall("_cat", tensors, dim).to(ATensor).newTensor()
proc u_cat*(tensors: TensorList, dim: int64 = 0): Tensor {.inline, noinit.} = dynamicCCall("at::_cat", tensors, dim).to(ATensor).newTensor()
proc binary_cross_entropy*(ty: TensorType; self: Tensor, target: Tensor, weight: Tensor, reduction: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("binary_cross_entropy_forward", self.tensor, target.tensor, weight.tensor, reduction).to(ATensor).newTensor()
proc binary_cross_entropy*(self: Tensor, target: Tensor, weight: Tensor, reduction: int64): Tensor {.inline, noinit.} = dynamicCCall("at::binary_cross_entropy_forward", self.tensor, target.tensor, weight.tensor, reduction).to(ATensor).newTensor()
proc binary_cross_entropy_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, target: Tensor, weight: Tensor, reduction: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("binary_cross_entropy_backward", grad_output.tensor, self.tensor, target.tensor, weight.tensor, reduction).to(ATensor).newTensor()
proc binary_cross_entropy_backward*(grad_output: Tensor, self: Tensor, target: Tensor, weight: Tensor, reduction: int64): Tensor {.inline, noinit.} = dynamicCCall("at::binary_cross_entropy_backward", grad_output.tensor, self.tensor, target.tensor, weight.tensor, reduction).to(ATensor).newTensor()
proc kl_div*(ty: TensorType; self: Tensor, target: Tensor, reduction: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("kl_div_forward", self.tensor, target.tensor, reduction).to(ATensor).newTensor()
proc kl_div*(self: Tensor, target: Tensor, reduction: int64): Tensor {.inline, noinit.} = dynamicCCall("at::kl_div_forward", self.tensor, target.tensor, reduction).to(ATensor).newTensor()
proc kl_div_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, target: Tensor, reduction: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("kl_div_backward", grad_output.tensor, self.tensor, target.tensor, reduction).to(ATensor).newTensor()
proc kl_div_backward*(grad_output: Tensor, self: Tensor, target: Tensor, reduction: int64): Tensor {.inline, noinit.} = dynamicCCall("at::kl_div_backward", grad_output.tensor, self.tensor, target.tensor, reduction).to(ATensor).newTensor()
proc l1_loss*(ty: TensorType; self: Tensor, target: Tensor, reduction: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("l1_loss_forward", self.tensor, target.tensor, reduction).to(ATensor).newTensor()
proc l1_loss*(self: Tensor, target: Tensor, reduction: int64): Tensor {.inline, noinit.} = dynamicCCall("at::l1_loss_forward", self.tensor, target.tensor, reduction).to(ATensor).newTensor()
proc l1_loss_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, target: Tensor, reduction: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("l1_loss_backward", grad_output.tensor, self.tensor, target.tensor, reduction).to(ATensor).newTensor()
proc l1_loss_backward*(grad_output: Tensor, self: Tensor, target: Tensor, reduction: int64): Tensor {.inline, noinit.} = dynamicCCall("at::l1_loss_backward", grad_output.tensor, self.tensor, target.tensor, reduction).to(ATensor).newTensor()
proc mse_loss*(ty: TensorType; self: Tensor, target: Tensor, reduction: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("mse_loss_forward", self.tensor, target.tensor, reduction).to(ATensor).newTensor()
proc mse_loss*(self: Tensor, target: Tensor, reduction: int64): Tensor {.inline, noinit.} = dynamicCCall("at::mse_loss_forward", self.tensor, target.tensor, reduction).to(ATensor).newTensor()
proc mse_loss_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, target: Tensor, reduction: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("mse_loss_backward", grad_output.tensor, self.tensor, target.tensor, reduction).to(ATensor).newTensor()
proc mse_loss_backward*(grad_output: Tensor, self: Tensor, target: Tensor, reduction: int64): Tensor {.inline, noinit.} = dynamicCCall("at::mse_loss_backward", grad_output.tensor, self.tensor, target.tensor, reduction).to(ATensor).newTensor()
proc multi_margin_loss*(ty: TensorType; self: Tensor, target: Tensor, p: float, margin: float, weight: Tensor, reduction: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("multi_margin_loss_forward", self.tensor, target.tensor, p, margin, weight.tensor, reduction).to(ATensor).newTensor()
proc multi_margin_loss*(self: Tensor, target: Tensor, p: float, margin: float, weight: Tensor, reduction: int64): Tensor {.inline, noinit.} = dynamicCCall("at::multi_margin_loss_forward", self.tensor, target.tensor, p, margin, weight.tensor, reduction).to(ATensor).newTensor()
proc multi_margin_loss_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, target: Tensor, p: float, margin: float, weight: Tensor, reduction: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("multi_margin_loss_backward", grad_output.tensor, self.tensor, target.tensor, p, margin, weight.tensor, reduction).to(ATensor).newTensor()
proc multi_margin_loss_backward*(grad_output: Tensor, self: Tensor, target: Tensor, p: float, margin: float, weight: Tensor, reduction: int64): Tensor {.inline, noinit.} = dynamicCCall("at::multi_margin_loss_backward", grad_output.tensor, self.tensor, target.tensor, p, margin, weight.tensor, reduction).to(ATensor).newTensor()
proc multilabel_margin_loss*(ty: TensorType; self: Tensor, target: Tensor, reduction: int64): tuple[output: Tensor, is_target: Tensor] {.inline, noinit.} = ty.dynamicCppCall("multilabel_margin_loss_forward", self.tensor, target.tensor, reduction).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc multilabel_margin_loss*(self: Tensor, target: Tensor, reduction: int64): tuple[output: Tensor, is_target: Tensor] {.inline, noinit.} = dynamicCCall("at::multilabel_margin_loss_forward", self.tensor, target.tensor, reduction).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc multilabel_margin_loss_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, target: Tensor, reduction: int64, is_target: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("multilabel_margin_loss_backward", grad_output.tensor, self.tensor, target.tensor, reduction, is_target.tensor).to(ATensor).newTensor()
proc multilabel_margin_loss_backward*(grad_output: Tensor, self: Tensor, target: Tensor, reduction: int64, is_target: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::multilabel_margin_loss_backward", grad_output.tensor, self.tensor, target.tensor, reduction, is_target.tensor).to(ATensor).newTensor()
proc nll_loss*(ty: TensorType; self: Tensor, target: Tensor, weight: Tensor, reduction: int64, ignore_index: int64): tuple[output: Tensor, total_weight: Tensor] {.inline, noinit.} = ty.dynamicCppCall("nll_loss_forward", self.tensor, target.tensor, weight.tensor, reduction, ignore_index).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc nll_loss*(self: Tensor, target: Tensor, weight: Tensor, reduction: int64, ignore_index: int64): tuple[output: Tensor, total_weight: Tensor] {.inline, noinit.} = dynamicCCall("at::nll_loss_forward", self.tensor, target.tensor, weight.tensor, reduction, ignore_index).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc nll_loss_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, target: Tensor, weight: Tensor, reduction: int64, ignore_index: int64, total_weight: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("nll_loss_backward", grad_output.tensor, self.tensor, target.tensor, weight.tensor, reduction, ignore_index, total_weight.tensor).to(ATensor).newTensor()
proc nll_loss_backward*(grad_output: Tensor, self: Tensor, target: Tensor, weight: Tensor, reduction: int64, ignore_index: int64, total_weight: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::nll_loss_backward", grad_output.tensor, self.tensor, target.tensor, weight.tensor, reduction, ignore_index, total_weight.tensor).to(ATensor).newTensor()
proc nll_loss2d*(ty: TensorType; self: Tensor, target: Tensor, weight: Tensor, reduction: int64, ignore_index: int64): tuple[output: Tensor, total_weight: Tensor] {.inline, noinit.} = ty.dynamicCppCall("nll_loss2d_forward", self.tensor, target.tensor, weight.tensor, reduction, ignore_index).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc nll_loss2d*(self: Tensor, target: Tensor, weight: Tensor, reduction: int64, ignore_index: int64): tuple[output: Tensor, total_weight: Tensor] {.inline, noinit.} = dynamicCCall("at::nll_loss2d_forward", self.tensor, target.tensor, weight.tensor, reduction, ignore_index).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc nll_loss2d_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, target: Tensor, weight: Tensor, reduction: int64, ignore_index: int64, total_weight: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("nll_loss2d_backward", grad_output.tensor, self.tensor, target.tensor, weight.tensor, reduction, ignore_index, total_weight.tensor).to(ATensor).newTensor()
proc nll_loss2d_backward*(grad_output: Tensor, self: Tensor, target: Tensor, weight: Tensor, reduction: int64, ignore_index: int64, total_weight: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::nll_loss2d_backward", grad_output.tensor, self.tensor, target.tensor, weight.tensor, reduction, ignore_index, total_weight.tensor).to(ATensor).newTensor()
proc smooth_l1_loss*(ty: TensorType; self: Tensor, target: Tensor, reduction: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("smooth_l1_loss_forward", self.tensor, target.tensor, reduction).to(ATensor).newTensor()
proc smooth_l1_loss*(self: Tensor, target: Tensor, reduction: int64): Tensor {.inline, noinit.} = dynamicCCall("at::smooth_l1_loss_forward", self.tensor, target.tensor, reduction).to(ATensor).newTensor()
proc smooth_l1_loss_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, target: Tensor, reduction: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("smooth_l1_loss_backward", grad_output.tensor, self.tensor, target.tensor, reduction).to(ATensor).newTensor()
proc smooth_l1_loss_backward*(grad_output: Tensor, self: Tensor, target: Tensor, reduction: int64): Tensor {.inline, noinit.} = dynamicCCall("at::smooth_l1_loss_backward", grad_output.tensor, self.tensor, target.tensor, reduction).to(ATensor).newTensor()
proc soft_margin_loss*(ty: TensorType; self: Tensor, target: Tensor, reduction: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("soft_margin_loss_forward", self.tensor, target.tensor, reduction).to(ATensor).newTensor()
proc soft_margin_loss*(self: Tensor, target: Tensor, reduction: int64): Tensor {.inline, noinit.} = dynamicCCall("at::soft_margin_loss_forward", self.tensor, target.tensor, reduction).to(ATensor).newTensor()
proc soft_margin_loss_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, target: Tensor, reduction: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("soft_margin_loss_backward", grad_output.tensor, self.tensor, target.tensor, reduction).to(ATensor).newTensor()
proc soft_margin_loss_backward*(grad_output: Tensor, self: Tensor, target: Tensor, reduction: int64): Tensor {.inline, noinit.} = dynamicCCall("at::soft_margin_loss_backward", grad_output.tensor, self.tensor, target.tensor, reduction).to(ATensor).newTensor()
proc elu*(ty: TensorType; self: Tensor, alpha: float, scale: float, input_scale: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("elu_forward", self.tensor, alpha, scale, input_scale).to(ATensor).newTensor()
proc elu*(self: Tensor, alpha: float, scale: float, input_scale: float): Tensor {.inline, noinit.} = dynamicCCall("at::elu_forward", self.tensor, alpha, scale, input_scale).to(ATensor).newTensor()
proc elu_backward*(ty: TensorType; grad_output: Tensor, alpha: float, scale: float, input_scale: float, output: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("elu_backward", grad_output.tensor, alpha, scale, input_scale, output.tensor).to(ATensor).newTensor()
proc elu_backward*(grad_output: Tensor, alpha: float, scale: float, input_scale: float, output: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::elu_backward", grad_output.tensor, alpha, scale, input_scale, output.tensor).to(ATensor).newTensor()
proc elu_u*(ty: TensorType; self: Tensor, alpha: float, scale: float, input_scale: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("elu_forward_", self.tensor, alpha, scale, input_scale).to(ATensor).newTensor()
proc elu_u*(self: Tensor, alpha: float, scale: float, input_scale: float): Tensor {.inline, noinit.} = dynamicCCall("at::elu_forward_", self.tensor, alpha, scale, input_scale).to(ATensor).newTensor()
proc glu*(ty: TensorType; self: Tensor, dim: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("glu_forward", self.tensor, dim).to(ATensor).newTensor()
proc glu*(self: Tensor, dim: int64): Tensor {.inline, noinit.} = dynamicCCall("at::glu_forward", self.tensor, dim).to(ATensor).newTensor()
proc glu_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, dim: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("glu_backward", grad_output.tensor, self.tensor, dim).to(ATensor).newTensor()
proc glu_backward*(grad_output: Tensor, self: Tensor, dim: int64): Tensor {.inline, noinit.} = dynamicCCall("at::glu_backward", grad_output.tensor, self.tensor, dim).to(ATensor).newTensor()
proc hardtanh*(ty: TensorType; self: Tensor, min_val: float, max_val: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("hardtanh_forward", self.tensor, min_val, max_val).to(ATensor).newTensor()
proc hardtanh*(self: Tensor, min_val: float, max_val: float): Tensor {.inline, noinit.} = dynamicCCall("at::hardtanh_forward", self.tensor, min_val, max_val).to(ATensor).newTensor()
proc hardtanh_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, min_val: float, max_val: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("hardtanh_backward", grad_output.tensor, self.tensor, min_val, max_val).to(ATensor).newTensor()
proc hardtanh_backward*(grad_output: Tensor, self: Tensor, min_val: float, max_val: float): Tensor {.inline, noinit.} = dynamicCCall("at::hardtanh_backward", grad_output.tensor, self.tensor, min_val, max_val).to(ATensor).newTensor()
proc hardtanh_u*(ty: TensorType; self: Tensor, min_val: float, max_val: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("hardtanh_forward_", self.tensor, min_val, max_val).to(ATensor).newTensor()
proc hardtanh_u*(self: Tensor, min_val: float, max_val: float): Tensor {.inline, noinit.} = dynamicCCall("at::hardtanh_forward_", self.tensor, min_val, max_val).to(ATensor).newTensor()
proc leaky_relu*(ty: TensorType; self: Tensor, negative_slope: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("leaky_relu_forward", self.tensor, negative_slope).to(ATensor).newTensor()
proc leaky_relu*(self: Tensor, negative_slope: float): Tensor {.inline, noinit.} = dynamicCCall("at::leaky_relu_forward", self.tensor, negative_slope).to(ATensor).newTensor()
proc leaky_relu_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, negative_slope: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("leaky_relu_backward", grad_output.tensor, self.tensor, negative_slope).to(ATensor).newTensor()
proc leaky_relu_backward*(grad_output: Tensor, self: Tensor, negative_slope: float): Tensor {.inline, noinit.} = dynamicCCall("at::leaky_relu_backward", grad_output.tensor, self.tensor, negative_slope).to(ATensor).newTensor()
proc leaky_relu_u*(ty: TensorType; self: Tensor, negative_slope: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("leaky_relu_forward_", self.tensor, negative_slope).to(ATensor).newTensor()
proc leaky_relu_u*(self: Tensor, negative_slope: float): Tensor {.inline, noinit.} = dynamicCCall("at::leaky_relu_forward_", self.tensor, negative_slope).to(ATensor).newTensor()
proc log_sigmoid*(ty: TensorType; self: Tensor): tuple[output: Tensor, buffer: Tensor] {.inline, noinit.} = ty.dynamicCppCall("log_sigmoid_forward", self.tensor).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc log_sigmoid*(self: Tensor): tuple[output: Tensor, buffer: Tensor] {.inline, noinit.} = dynamicCCall("at::log_sigmoid_forward", self.tensor).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc log_sigmoid_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, buffer: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("log_sigmoid_backward", grad_output.tensor, self.tensor, buffer.tensor).to(ATensor).newTensor()
proc log_sigmoid_backward*(grad_output: Tensor, self: Tensor, buffer: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::log_sigmoid_backward", grad_output.tensor, self.tensor, buffer.tensor).to(ATensor).newTensor()
proc prelu*(ty: TensorType; self: Tensor, weight: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("prelu_forward", self.tensor, weight.tensor).to(ATensor).newTensor()
proc prelu*(self: Tensor, weight: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::prelu_forward", self.tensor, weight.tensor).to(ATensor).newTensor()
proc prelu_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, weight: Tensor, output_mask: StdArray[bool, 2]): tuple[self: Tensor, weight: Tensor] {.inline, noinit.} = ty.dynamicCppCall("prelu_backward", grad_output.tensor, self.tensor, weight.tensor, output_mask).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc prelu_backward*(grad_output: Tensor, self: Tensor, weight: Tensor, output_mask: StdArray[bool, 2]): tuple[self: Tensor, weight: Tensor] {.inline, noinit.} = dynamicCCall("at::prelu_backward", grad_output.tensor, self.tensor, weight.tensor, output_mask).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc rrelu_with_noise*(ty: TensorType; self: Tensor, noise: Tensor, lower: float, upper: float, training: bool, generator: pointer): Tensor {.inline, noinit.} = ty.dynamicCppCall("rrelu_with_noise_forward", self.tensor, noise.tensor, lower, upper, training, generator).to(ATensor).newTensor()
proc rrelu_with_noise*(self: Tensor, noise: Tensor, lower: float, upper: float, training: bool, generator: pointer): Tensor {.inline, noinit.} = dynamicCCall("at::rrelu_with_noise_forward", self.tensor, noise.tensor, lower, upper, training, generator).to(ATensor).newTensor()
proc rrelu_with_noise_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, noise: Tensor, lower: float, upper: float, training: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("rrelu_with_noise_backward", grad_output.tensor, self.tensor, noise.tensor, lower, upper, training).to(ATensor).newTensor()
proc rrelu_with_noise_backward*(grad_output: Tensor, self: Tensor, noise: Tensor, lower: float, upper: float, training: bool): Tensor {.inline, noinit.} = dynamicCCall("at::rrelu_with_noise_backward", grad_output.tensor, self.tensor, noise.tensor, lower, upper, training).to(ATensor).newTensor()
proc rrelu_with_noise_u*(ty: TensorType; self: Tensor, noise: Tensor, lower: float, upper: float, training: bool, generator: pointer): Tensor {.inline, noinit.} = ty.dynamicCppCall("rrelu_with_noise_forward_", self.tensor, noise.tensor, lower, upper, training, generator).to(ATensor).newTensor()
proc rrelu_with_noise_u*(self: Tensor, noise: Tensor, lower: float, upper: float, training: bool, generator: pointer): Tensor {.inline, noinit.} = dynamicCCall("at::rrelu_with_noise_forward_", self.tensor, noise.tensor, lower, upper, training, generator).to(ATensor).newTensor()
proc softplus*(ty: TensorType; self: Tensor, beta: float, threshold: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("softplus_forward", self.tensor, beta, threshold).to(ATensor).newTensor()
proc softplus*(self: Tensor, beta: float, threshold: float): Tensor {.inline, noinit.} = dynamicCCall("at::softplus_forward", self.tensor, beta, threshold).to(ATensor).newTensor()
proc softplus_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, beta: float, threshold: float, output: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("softplus_backward", grad_output.tensor, self.tensor, beta, threshold, output.tensor).to(ATensor).newTensor()
proc softplus_backward*(grad_output: Tensor, self: Tensor, beta: float, threshold: float, output: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::softplus_backward", grad_output.tensor, self.tensor, beta, threshold, output.tensor).to(ATensor).newTensor()
proc softshrink*(ty: TensorType; self: Tensor, lambd: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("softshrink_forward", self.tensor, lambd).to(ATensor).newTensor()
proc softshrink*(self: Tensor, lambd: float): Tensor {.inline, noinit.} = dynamicCCall("at::softshrink_forward", self.tensor, lambd).to(ATensor).newTensor()
proc softshrink_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, lambd: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("softshrink_backward", grad_output.tensor, self.tensor, lambd).to(ATensor).newTensor()
proc softshrink_backward*(grad_output: Tensor, self: Tensor, lambd: float): Tensor {.inline, noinit.} = dynamicCCall("at::softshrink_backward", grad_output.tensor, self.tensor, lambd).to(ATensor).newTensor()
proc threshold*(ty: TensorType; self: Tensor, threshold: float, value: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("threshold_forward", self.tensor, threshold, value).to(ATensor).newTensor()
proc threshold*(self: Tensor, threshold: float, value: float): Tensor {.inline, noinit.} = dynamicCCall("at::threshold_forward", self.tensor, threshold, value).to(ATensor).newTensor()
proc threshold_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, threshold: float, value: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("threshold_backward", grad_output.tensor, self.tensor, threshold, value).to(ATensor).newTensor()
proc threshold_backward*(grad_output: Tensor, self: Tensor, threshold: float, value: float): Tensor {.inline, noinit.} = dynamicCCall("at::threshold_backward", grad_output.tensor, self.tensor, threshold, value).to(ATensor).newTensor()
proc threshold_u*(ty: TensorType; self: Tensor, threshold: float, value: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("threshold_forward_", self.tensor, threshold, value).to(ATensor).newTensor()
proc threshold_u*(self: Tensor, threshold: float, value: float): Tensor {.inline, noinit.} = dynamicCCall("at::threshold_forward_", self.tensor, threshold, value).to(ATensor).newTensor()
proc adaptive_avg_pool2d*(ty: TensorType; self: Tensor, output_size: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("adaptive_avg_pool2d_forward", self.tensor, output_size).to(ATensor).newTensor()
proc adaptive_avg_pool2d*(self: Tensor, output_size: IntList): Tensor {.inline, noinit.} = dynamicCCall("at::adaptive_avg_pool2d_forward", self.tensor, output_size).to(ATensor).newTensor()
proc adaptive_avg_pool2d_backward*(ty: TensorType; grad_output: Tensor, self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("adaptive_avg_pool2d_backward", grad_output.tensor, self.tensor).to(ATensor).newTensor()
proc adaptive_avg_pool2d_backward*(grad_output: Tensor, self: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::adaptive_avg_pool2d_backward", grad_output.tensor, self.tensor).to(ATensor).newTensor()
proc adaptive_avg_pool3d*(ty: TensorType; self: Tensor, output_size: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("adaptive_avg_pool3d_forward", self.tensor, output_size).to(ATensor).newTensor()
proc adaptive_avg_pool3d*(self: Tensor, output_size: IntList): Tensor {.inline, noinit.} = dynamicCCall("at::adaptive_avg_pool3d_forward", self.tensor, output_size).to(ATensor).newTensor()
proc adaptive_avg_pool3d_backward*(ty: TensorType; grad_output: Tensor, self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("adaptive_avg_pool3d_backward", grad_output.tensor, self.tensor).to(ATensor).newTensor()
proc adaptive_avg_pool3d_backward*(grad_output: Tensor, self: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::adaptive_avg_pool3d_backward", grad_output.tensor, self.tensor).to(ATensor).newTensor()
proc adaptive_max_pool2d*(ty: TensorType; self: Tensor, output_size: IntList): tuple[output: Tensor, indices: Tensor] {.inline, noinit.} = ty.dynamicCppCall("adaptive_max_pool2d_forward", self.tensor, output_size).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc adaptive_max_pool2d*(self: Tensor, output_size: IntList): tuple[output: Tensor, indices: Tensor] {.inline, noinit.} = dynamicCCall("at::adaptive_max_pool2d_forward", self.tensor, output_size).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc adaptive_max_pool2d_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, indices: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("adaptive_max_pool2d_backward", grad_output.tensor, self.tensor, indices.tensor).to(ATensor).newTensor()
proc adaptive_max_pool2d_backward*(grad_output: Tensor, self: Tensor, indices: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::adaptive_max_pool2d_backward", grad_output.tensor, self.tensor, indices.tensor).to(ATensor).newTensor()
proc adaptive_max_pool3d*(ty: TensorType; self: Tensor, output_size: IntList): tuple[output: Tensor, indices: Tensor] {.inline, noinit.} = ty.dynamicCppCall("adaptive_max_pool3d_forward", self.tensor, output_size).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc adaptive_max_pool3d*(self: Tensor, output_size: IntList): tuple[output: Tensor, indices: Tensor] {.inline, noinit.} = dynamicCCall("at::adaptive_max_pool3d_forward", self.tensor, output_size).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc adaptive_max_pool3d_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, indices: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("adaptive_max_pool3d_backward", grad_output.tensor, self.tensor, indices.tensor).to(ATensor).newTensor()
proc adaptive_max_pool3d_backward*(grad_output: Tensor, self: Tensor, indices: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::adaptive_max_pool3d_backward", grad_output.tensor, self.tensor, indices.tensor).to(ATensor).newTensor()
proc avg_pool2d*(ty: TensorType; self: Tensor, kernel_size: IntList, stride: IntList, padding: IntList, ceil_mode: bool, count_include_pad: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("avg_pool2d_forward", self.tensor, kernel_size, stride, padding, ceil_mode, count_include_pad).to(ATensor).newTensor()
proc avg_pool2d*(self: Tensor, kernel_size: IntList, stride: IntList, padding: IntList, ceil_mode: bool, count_include_pad: bool): Tensor {.inline, noinit.} = dynamicCCall("at::avg_pool2d_forward", self.tensor, kernel_size, stride, padding, ceil_mode, count_include_pad).to(ATensor).newTensor()
proc avg_pool2d_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, kernel_size: IntList, stride: IntList, padding: IntList, ceil_mode: bool, count_include_pad: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("avg_pool2d_backward", grad_output.tensor, self.tensor, kernel_size, stride, padding, ceil_mode, count_include_pad).to(ATensor).newTensor()
proc avg_pool2d_backward*(grad_output: Tensor, self: Tensor, kernel_size: IntList, stride: IntList, padding: IntList, ceil_mode: bool, count_include_pad: bool): Tensor {.inline, noinit.} = dynamicCCall("at::avg_pool2d_backward", grad_output.tensor, self.tensor, kernel_size, stride, padding, ceil_mode, count_include_pad).to(ATensor).newTensor()
proc avg_pool3d*(ty: TensorType; self: Tensor, kernel_size: IntList, stride: IntList, padding: IntList, ceil_mode: bool, count_include_pad: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("avg_pool3d_forward", self.tensor, kernel_size, stride, padding, ceil_mode, count_include_pad).to(ATensor).newTensor()
proc avg_pool3d*(self: Tensor, kernel_size: IntList, stride: IntList, padding: IntList, ceil_mode: bool, count_include_pad: bool): Tensor {.inline, noinit.} = dynamicCCall("at::avg_pool3d_forward", self.tensor, kernel_size, stride, padding, ceil_mode, count_include_pad).to(ATensor).newTensor()
proc avg_pool3d_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, kernel_size: IntList, stride: IntList, padding: IntList, ceil_mode: bool, count_include_pad: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("avg_pool3d_backward", grad_output.tensor, self.tensor, kernel_size, stride, padding, ceil_mode, count_include_pad).to(ATensor).newTensor()
proc avg_pool3d_backward*(grad_output: Tensor, self: Tensor, kernel_size: IntList, stride: IntList, padding: IntList, ceil_mode: bool, count_include_pad: bool): Tensor {.inline, noinit.} = dynamicCCall("at::avg_pool3d_backward", grad_output.tensor, self.tensor, kernel_size, stride, padding, ceil_mode, count_include_pad).to(ATensor).newTensor()
proc fractional_max_pool2d*(ty: TensorType; self: Tensor, kernel_size: IntList, output_size: IntList, random_samples: Tensor): tuple[output: Tensor, indices: Tensor] {.inline, noinit.} = ty.dynamicCppCall("fractional_max_pool2d_forward", self.tensor, kernel_size, output_size, random_samples.tensor).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc fractional_max_pool2d*(self: Tensor, kernel_size: IntList, output_size: IntList, random_samples: Tensor): tuple[output: Tensor, indices: Tensor] {.inline, noinit.} = dynamicCCall("at::fractional_max_pool2d_forward", self.tensor, kernel_size, output_size, random_samples.tensor).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc fractional_max_pool2d_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, kernel_size: IntList, output_size: IntList, indices: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("fractional_max_pool2d_backward", grad_output.tensor, self.tensor, kernel_size, output_size, indices.tensor).to(ATensor).newTensor()
proc fractional_max_pool2d_backward*(grad_output: Tensor, self: Tensor, kernel_size: IntList, output_size: IntList, indices: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::fractional_max_pool2d_backward", grad_output.tensor, self.tensor, kernel_size, output_size, indices.tensor).to(ATensor).newTensor()
proc max_pool2d_with_indices*(ty: TensorType; self: Tensor, kernel_size: IntList, stride: IntList, padding: IntList, dilation: IntList, ceil_mode: bool): tuple[output: Tensor, indices: Tensor] {.inline, noinit.} = ty.dynamicCppCall("max_pool2d_with_indices_forward", self.tensor, kernel_size, stride, padding, dilation, ceil_mode).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc max_pool2d_with_indices*(self: Tensor, kernel_size: IntList, stride: IntList, padding: IntList, dilation: IntList, ceil_mode: bool): tuple[output: Tensor, indices: Tensor] {.inline, noinit.} = dynamicCCall("at::max_pool2d_with_indices_forward", self.tensor, kernel_size, stride, padding, dilation, ceil_mode).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc max_pool2d_with_indices_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, kernel_size: IntList, stride: IntList, padding: IntList, dilation: IntList, ceil_mode: bool, indices: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("max_pool2d_with_indices_backward", grad_output.tensor, self.tensor, kernel_size, stride, padding, dilation, ceil_mode, indices.tensor).to(ATensor).newTensor()
proc max_pool2d_with_indices_backward*(grad_output: Tensor, self: Tensor, kernel_size: IntList, stride: IntList, padding: IntList, dilation: IntList, ceil_mode: bool, indices: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::max_pool2d_with_indices_backward", grad_output.tensor, self.tensor, kernel_size, stride, padding, dilation, ceil_mode, indices.tensor).to(ATensor).newTensor()
proc max_pool3d_with_indices*(ty: TensorType; self: Tensor, kernel_size: IntList, stride: IntList, padding: IntList, dilation: IntList, ceil_mode: bool): tuple[output: Tensor, indices: Tensor] {.inline, noinit.} = ty.dynamicCppCall("max_pool3d_with_indices_forward", self.tensor, kernel_size, stride, padding, dilation, ceil_mode).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc max_pool3d_with_indices*(self: Tensor, kernel_size: IntList, stride: IntList, padding: IntList, dilation: IntList, ceil_mode: bool): tuple[output: Tensor, indices: Tensor] {.inline, noinit.} = dynamicCCall("at::max_pool3d_with_indices_forward", self.tensor, kernel_size, stride, padding, dilation, ceil_mode).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc max_pool3d_with_indices_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, kernel_size: IntList, stride: IntList, padding: IntList, dilation: IntList, ceil_mode: bool, indices: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("max_pool3d_with_indices_backward", grad_output.tensor, self.tensor, kernel_size, stride, padding, dilation, ceil_mode, indices.tensor).to(ATensor).newTensor()
proc max_pool3d_with_indices_backward*(grad_output: Tensor, self: Tensor, kernel_size: IntList, stride: IntList, padding: IntList, dilation: IntList, ceil_mode: bool, indices: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::max_pool3d_with_indices_backward", grad_output.tensor, self.tensor, kernel_size, stride, padding, dilation, ceil_mode, indices.tensor).to(ATensor).newTensor()
proc max_unpool2d*(ty: TensorType; self: Tensor, indices: Tensor, output_size: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("max_unpool2d_forward", self.tensor, indices.tensor, output_size).to(ATensor).newTensor()
proc max_unpool2d*(self: Tensor, indices: Tensor, output_size: IntList): Tensor {.inline, noinit.} = dynamicCCall("at::max_unpool2d_forward", self.tensor, indices.tensor, output_size).to(ATensor).newTensor()
proc max_unpool2d_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, indices: Tensor, output_size: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("max_unpool2d_backward", grad_output.tensor, self.tensor, indices.tensor, output_size).to(ATensor).newTensor()
proc max_unpool2d_backward*(grad_output: Tensor, self: Tensor, indices: Tensor, output_size: IntList): Tensor {.inline, noinit.} = dynamicCCall("at::max_unpool2d_backward", grad_output.tensor, self.tensor, indices.tensor, output_size).to(ATensor).newTensor()
proc max_unpool3d*(ty: TensorType; self: Tensor, indices: Tensor, output_size: IntList, stride: IntList, padding: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("max_unpool3d_forward", self.tensor, indices.tensor, output_size, stride, padding).to(ATensor).newTensor()
proc max_unpool3d*(self: Tensor, indices: Tensor, output_size: IntList, stride: IntList, padding: IntList): Tensor {.inline, noinit.} = dynamicCCall("at::max_unpool3d_forward", self.tensor, indices.tensor, output_size, stride, padding).to(ATensor).newTensor()
proc max_unpool3d_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, indices: Tensor, output_size: IntList, stride: IntList, padding: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("max_unpool3d_backward", grad_output.tensor, self.tensor, indices.tensor, output_size, stride, padding).to(ATensor).newTensor()
proc max_unpool3d_backward*(grad_output: Tensor, self: Tensor, indices: Tensor, output_size: IntList, stride: IntList, padding: IntList): Tensor {.inline, noinit.} = dynamicCCall("at::max_unpool3d_backward", grad_output.tensor, self.tensor, indices.tensor, output_size, stride, padding).to(ATensor).newTensor()
proc reflection_pad1d*(ty: TensorType; self: Tensor, padding: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("reflection_pad1d_forward", self.tensor, padding).to(ATensor).newTensor()
proc reflection_pad1d*(self: Tensor, padding: IntList): Tensor {.inline, noinit.} = dynamicCCall("at::reflection_pad1d_forward", self.tensor, padding).to(ATensor).newTensor()
proc reflection_pad1d_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, padding: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("reflection_pad1d_backward", grad_output.tensor, self.tensor, padding).to(ATensor).newTensor()
proc reflection_pad1d_backward*(grad_output: Tensor, self: Tensor, padding: IntList): Tensor {.inline, noinit.} = dynamicCCall("at::reflection_pad1d_backward", grad_output.tensor, self.tensor, padding).to(ATensor).newTensor()
proc reflection_pad2d*(ty: TensorType; self: Tensor, padding: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("reflection_pad2d_forward", self.tensor, padding).to(ATensor).newTensor()
proc reflection_pad2d*(self: Tensor, padding: IntList): Tensor {.inline, noinit.} = dynamicCCall("at::reflection_pad2d_forward", self.tensor, padding).to(ATensor).newTensor()
proc reflection_pad2d_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, padding: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("reflection_pad2d_backward", grad_output.tensor, self.tensor, padding).to(ATensor).newTensor()
proc reflection_pad2d_backward*(grad_output: Tensor, self: Tensor, padding: IntList): Tensor {.inline, noinit.} = dynamicCCall("at::reflection_pad2d_backward", grad_output.tensor, self.tensor, padding).to(ATensor).newTensor()
proc replication_pad1d*(ty: TensorType; self: Tensor, padding: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("replication_pad1d_forward", self.tensor, padding).to(ATensor).newTensor()
proc replication_pad1d*(self: Tensor, padding: IntList): Tensor {.inline, noinit.} = dynamicCCall("at::replication_pad1d_forward", self.tensor, padding).to(ATensor).newTensor()
proc replication_pad1d_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, padding: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("replication_pad1d_backward", grad_output.tensor, self.tensor, padding).to(ATensor).newTensor()
proc replication_pad1d_backward*(grad_output: Tensor, self: Tensor, padding: IntList): Tensor {.inline, noinit.} = dynamicCCall("at::replication_pad1d_backward", grad_output.tensor, self.tensor, padding).to(ATensor).newTensor()
proc replication_pad2d*(ty: TensorType; self: Tensor, padding: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("replication_pad2d_forward", self.tensor, padding).to(ATensor).newTensor()
proc replication_pad2d*(self: Tensor, padding: IntList): Tensor {.inline, noinit.} = dynamicCCall("at::replication_pad2d_forward", self.tensor, padding).to(ATensor).newTensor()
proc replication_pad2d_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, padding: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("replication_pad2d_backward", grad_output.tensor, self.tensor, padding).to(ATensor).newTensor()
proc replication_pad2d_backward*(grad_output: Tensor, self: Tensor, padding: IntList): Tensor {.inline, noinit.} = dynamicCCall("at::replication_pad2d_backward", grad_output.tensor, self.tensor, padding).to(ATensor).newTensor()
proc replication_pad3d*(ty: TensorType; self: Tensor, padding: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("replication_pad3d_forward", self.tensor, padding).to(ATensor).newTensor()
proc replication_pad3d*(self: Tensor, padding: IntList): Tensor {.inline, noinit.} = dynamicCCall("at::replication_pad3d_forward", self.tensor, padding).to(ATensor).newTensor()
proc replication_pad3d_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, padding: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("replication_pad3d_backward", grad_output.tensor, self.tensor, padding).to(ATensor).newTensor()
proc replication_pad3d_backward*(grad_output: Tensor, self: Tensor, padding: IntList): Tensor {.inline, noinit.} = dynamicCCall("at::replication_pad3d_backward", grad_output.tensor, self.tensor, padding).to(ATensor).newTensor()
proc upsample_linear1d*(ty: TensorType; self: Tensor, output_size: IntList, align_corners: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("upsample_linear1d_forward", self.tensor, output_size, align_corners).to(ATensor).newTensor()
proc upsample_linear1d*(self: Tensor, output_size: IntList, align_corners: bool): Tensor {.inline, noinit.} = dynamicCCall("at::upsample_linear1d_forward", self.tensor, output_size, align_corners).to(ATensor).newTensor()
proc upsample_linear1d_backward*(ty: TensorType; grad_output: Tensor, output_size: IntList, input_size: IntList, align_corners: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("upsample_linear1d_backward", grad_output.tensor, output_size, input_size, align_corners).to(ATensor).newTensor()
proc upsample_linear1d_backward*(grad_output: Tensor, output_size: IntList, input_size: IntList, align_corners: bool): Tensor {.inline, noinit.} = dynamicCCall("at::upsample_linear1d_backward", grad_output.tensor, output_size, input_size, align_corners).to(ATensor).newTensor()
proc upsample_bilinear2d*(ty: TensorType; self: Tensor, output_size: IntList, align_corners: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("upsample_bilinear2d_forward", self.tensor, output_size, align_corners).to(ATensor).newTensor()
proc upsample_bilinear2d*(self: Tensor, output_size: IntList, align_corners: bool): Tensor {.inline, noinit.} = dynamicCCall("at::upsample_bilinear2d_forward", self.tensor, output_size, align_corners).to(ATensor).newTensor()
proc upsample_bilinear2d_backward*(ty: TensorType; grad_output: Tensor, output_size: IntList, input_size: IntList, align_corners: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("upsample_bilinear2d_backward", grad_output.tensor, output_size, input_size, align_corners).to(ATensor).newTensor()
proc upsample_bilinear2d_backward*(grad_output: Tensor, output_size: IntList, input_size: IntList, align_corners: bool): Tensor {.inline, noinit.} = dynamicCCall("at::upsample_bilinear2d_backward", grad_output.tensor, output_size, input_size, align_corners).to(ATensor).newTensor()
proc upsample_trilinear3d*(ty: TensorType; self: Tensor, output_size: IntList, align_corners: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("upsample_trilinear3d_forward", self.tensor, output_size, align_corners).to(ATensor).newTensor()
proc upsample_trilinear3d*(self: Tensor, output_size: IntList, align_corners: bool): Tensor {.inline, noinit.} = dynamicCCall("at::upsample_trilinear3d_forward", self.tensor, output_size, align_corners).to(ATensor).newTensor()
proc upsample_trilinear3d_backward*(ty: TensorType; grad_output: Tensor, output_size: IntList, input_size: IntList, align_corners: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("upsample_trilinear3d_backward", grad_output.tensor, output_size, input_size, align_corners).to(ATensor).newTensor()
proc upsample_trilinear3d_backward*(grad_output: Tensor, output_size: IntList, input_size: IntList, align_corners: bool): Tensor {.inline, noinit.} = dynamicCCall("at::upsample_trilinear3d_backward", grad_output.tensor, output_size, input_size, align_corners).to(ATensor).newTensor()
proc upsample_nearest1d*(ty: TensorType; self: Tensor, output_size: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("upsample_nearest1d_forward", self.tensor, output_size).to(ATensor).newTensor()
proc upsample_nearest1d*(self: Tensor, output_size: IntList): Tensor {.inline, noinit.} = dynamicCCall("at::upsample_nearest1d_forward", self.tensor, output_size).to(ATensor).newTensor()
proc upsample_nearest1d_backward*(ty: TensorType; grad_output: Tensor, output_size: IntList, input_size: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("upsample_nearest1d_backward", grad_output.tensor, output_size, input_size).to(ATensor).newTensor()
proc upsample_nearest1d_backward*(grad_output: Tensor, output_size: IntList, input_size: IntList): Tensor {.inline, noinit.} = dynamicCCall("at::upsample_nearest1d_backward", grad_output.tensor, output_size, input_size).to(ATensor).newTensor()
proc upsample_nearest2d*(ty: TensorType; self: Tensor, output_size: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("upsample_nearest2d_forward", self.tensor, output_size).to(ATensor).newTensor()
proc upsample_nearest2d*(self: Tensor, output_size: IntList): Tensor {.inline, noinit.} = dynamicCCall("at::upsample_nearest2d_forward", self.tensor, output_size).to(ATensor).newTensor()
proc upsample_nearest2d_backward*(ty: TensorType; grad_output: Tensor, output_size: IntList, input_size: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("upsample_nearest2d_backward", grad_output.tensor, output_size, input_size).to(ATensor).newTensor()
proc upsample_nearest2d_backward*(grad_output: Tensor, output_size: IntList, input_size: IntList): Tensor {.inline, noinit.} = dynamicCCall("at::upsample_nearest2d_backward", grad_output.tensor, output_size, input_size).to(ATensor).newTensor()
proc upsample_nearest3d*(ty: TensorType; self: Tensor, output_size: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("upsample_nearest3d_forward", self.tensor, output_size).to(ATensor).newTensor()
proc upsample_nearest3d*(self: Tensor, output_size: IntList): Tensor {.inline, noinit.} = dynamicCCall("at::upsample_nearest3d_forward", self.tensor, output_size).to(ATensor).newTensor()
proc upsample_nearest3d_backward*(ty: TensorType; grad_output: Tensor, output_size: IntList, input_size: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("upsample_nearest3d_backward", grad_output.tensor, output_size, input_size).to(ATensor).newTensor()
proc upsample_nearest3d_backward*(grad_output: Tensor, output_size: IntList, input_size: IntList): Tensor {.inline, noinit.} = dynamicCCall("at::upsample_nearest3d_backward", grad_output.tensor, output_size, input_size).to(ATensor).newTensor()
proc u_sigmoid*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_sigmoid_forward", self.tensor).to(ATensor).newTensor()
proc u_sigmoid*(self: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::_sigmoid_forward", self.tensor).to(ATensor).newTensor()
proc u_sigmoid_backward*(ty: TensorType; grad_output: Tensor, output: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_sigmoid_backward", grad_output.tensor, output.tensor).to(ATensor).newTensor()
proc u_sigmoid_backward*(grad_output: Tensor, output: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::_sigmoid_backward", grad_output.tensor, output.tensor).to(ATensor).newTensor()
proc u_tanh*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_tanh_forward", self.tensor).to(ATensor).newTensor()
proc u_tanh*(self: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::_tanh_forward", self.tensor).to(ATensor).newTensor()
proc u_tanh_backward*(ty: TensorType; grad_output: Tensor, output: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_tanh_backward", grad_output.tensor, output.tensor).to(ATensor).newTensor()
proc u_tanh_backward*(grad_output: Tensor, output: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::_tanh_backward", grad_output.tensor, output.tensor).to(ATensor).newTensor()
proc thnn_batch_norm*(ty: TensorType; self: Tensor, weight: Tensor, bias: Tensor, running_mean: Tensor, running_var: Tensor, training: bool, momentum: float64, eps: float64): tuple[output: Tensor, save_mean: Tensor, save_std: Tensor] {.inline, noinit.} = ty.dynamicCppCall("thnn_batch_norm_forward", self.tensor, weight.tensor, bias.tensor, running_mean.tensor, running_var.tensor, training, momentum, eps).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc thnn_batch_norm*(self: Tensor, weight: Tensor, bias: Tensor, running_mean: Tensor, running_var: Tensor, training: bool, momentum: float64, eps: float64): tuple[output: Tensor, save_mean: Tensor, save_std: Tensor] {.inline, noinit.} = dynamicCCall("at::thnn_batch_norm_forward", self.tensor, weight.tensor, bias.tensor, running_mean.tensor, running_var.tensor, training, momentum, eps).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc thnn_batch_norm_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, weight: Tensor, running_mean: Tensor, running_var: Tensor, training: bool, eps: float64, save_mean: Tensor, save_std: Tensor, output_mask: StdArray[bool, 3]): tuple[self: Tensor, weight: Tensor, bias: Tensor] {.inline, noinit.} = ty.dynamicCppCall("thnn_batch_norm_backward", grad_output.tensor, self.tensor, weight.tensor, running_mean.tensor, running_var.tensor, training, eps, save_mean.tensor, save_std.tensor, output_mask).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc thnn_batch_norm_backward*(grad_output: Tensor, self: Tensor, weight: Tensor, running_mean: Tensor, running_var: Tensor, training: bool, eps: float64, save_mean: Tensor, save_std: Tensor, output_mask: StdArray[bool, 3]): tuple[self: Tensor, weight: Tensor, bias: Tensor] {.inline, noinit.} = dynamicCCall("at::thnn_batch_norm_backward", grad_output.tensor, self.tensor, weight.tensor, running_mean.tensor, running_var.tensor, training, eps, save_mean.tensor, save_std.tensor, output_mask).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc thnn_conv_transpose2d*(ty: TensorType; self: Tensor, weight: Tensor, kernel_size: IntList, bias: Tensor, stride: IntList, padding: IntList, output_padding: IntList, dilation: IntList): tuple[output: Tensor, columns: Tensor, ones: Tensor] {.inline, noinit.} = ty.dynamicCppCall("thnn_conv_transpose2d_forward", self.tensor, weight.tensor, kernel_size, bias.tensor, stride, padding, output_padding, dilation).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc thnn_conv_transpose2d*(self: Tensor, weight: Tensor, kernel_size: IntList, bias: Tensor, stride: IntList, padding: IntList, output_padding: IntList, dilation: IntList): tuple[output: Tensor, columns: Tensor, ones: Tensor] {.inline, noinit.} = dynamicCCall("at::thnn_conv_transpose2d_forward", self.tensor, weight.tensor, kernel_size, bias.tensor, stride, padding, output_padding, dilation).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc thnn_conv_transpose2d_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, weight: Tensor, kernel_size: IntList, stride: IntList, padding: IntList, output_padding: IntList, dilation: IntList, columns: Tensor, ones: Tensor, output_mask: StdArray[bool, 3]): tuple[self: Tensor, weight: Tensor, bias: Tensor] {.inline, noinit.} = ty.dynamicCppCall("thnn_conv_transpose2d_backward", grad_output.tensor, self.tensor, weight.tensor, kernel_size, stride, padding, output_padding, dilation, columns.tensor, ones.tensor, output_mask).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc thnn_conv_transpose2d_backward*(grad_output: Tensor, self: Tensor, weight: Tensor, kernel_size: IntList, stride: IntList, padding: IntList, output_padding: IntList, dilation: IntList, columns: Tensor, ones: Tensor, output_mask: StdArray[bool, 3]): tuple[self: Tensor, weight: Tensor, bias: Tensor] {.inline, noinit.} = dynamicCCall("at::thnn_conv_transpose2d_backward", grad_output.tensor, self.tensor, weight.tensor, kernel_size, stride, padding, output_padding, dilation, columns.tensor, ones.tensor, output_mask).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc thnn_conv_transpose3d*(ty: TensorType; self: Tensor, weight: Tensor, kernel_size: IntList, bias: Tensor, stride: IntList, padding: IntList, output_padding: IntList, dilation: IntList): tuple[output: Tensor, finput: Tensor, fgrad_input: Tensor] {.inline, noinit.} = ty.dynamicCppCall("thnn_conv_transpose3d_forward", self.tensor, weight.tensor, kernel_size, bias.tensor, stride, padding, output_padding, dilation).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc thnn_conv_transpose3d*(self: Tensor, weight: Tensor, kernel_size: IntList, bias: Tensor, stride: IntList, padding: IntList, output_padding: IntList, dilation: IntList): tuple[output: Tensor, finput: Tensor, fgrad_input: Tensor] {.inline, noinit.} = dynamicCCall("at::thnn_conv_transpose3d_forward", self.tensor, weight.tensor, kernel_size, bias.tensor, stride, padding, output_padding, dilation).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc thnn_conv_transpose3d_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, weight: Tensor, kernel_size: IntList, stride: IntList, padding: IntList, output_padding: IntList, dilation: IntList, finput: Tensor, fgrad_input: Tensor, output_mask: StdArray[bool, 3]): tuple[self: Tensor, weight: Tensor, bias: Tensor] {.inline, noinit.} = ty.dynamicCppCall("thnn_conv_transpose3d_backward", grad_output.tensor, self.tensor, weight.tensor, kernel_size, stride, padding, output_padding, dilation, finput.tensor, fgrad_input.tensor, output_mask).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc thnn_conv_transpose3d_backward*(grad_output: Tensor, self: Tensor, weight: Tensor, kernel_size: IntList, stride: IntList, padding: IntList, output_padding: IntList, dilation: IntList, finput: Tensor, fgrad_input: Tensor, output_mask: StdArray[bool, 3]): tuple[self: Tensor, weight: Tensor, bias: Tensor] {.inline, noinit.} = dynamicCCall("at::thnn_conv_transpose3d_backward", grad_output.tensor, self.tensor, weight.tensor, kernel_size, stride, padding, output_padding, dilation, finput.tensor, fgrad_input.tensor, output_mask).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc thnn_conv2d*(ty: TensorType; self: Tensor, weight: Tensor, kernel_size: IntList, bias: Tensor, stride: IntList, padding: IntList): tuple[output: Tensor, finput: Tensor, fgrad_input: Tensor] {.inline, noinit.} = ty.dynamicCppCall("thnn_conv2d_forward", self.tensor, weight.tensor, kernel_size, bias.tensor, stride, padding).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc thnn_conv2d*(self: Tensor, weight: Tensor, kernel_size: IntList, bias: Tensor, stride: IntList, padding: IntList): tuple[output: Tensor, finput: Tensor, fgrad_input: Tensor] {.inline, noinit.} = dynamicCCall("at::thnn_conv2d_forward", self.tensor, weight.tensor, kernel_size, bias.tensor, stride, padding).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc thnn_conv2d_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, weight: Tensor, kernel_size: IntList, stride: IntList, padding: IntList, finput: Tensor, fgrad_input: Tensor, output_mask: StdArray[bool, 3]): tuple[self: Tensor, weight: Tensor, bias: Tensor] {.inline, noinit.} = ty.dynamicCppCall("thnn_conv2d_backward", grad_output.tensor, self.tensor, weight.tensor, kernel_size, stride, padding, finput.tensor, fgrad_input.tensor, output_mask).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc thnn_conv2d_backward*(grad_output: Tensor, self: Tensor, weight: Tensor, kernel_size: IntList, stride: IntList, padding: IntList, finput: Tensor, fgrad_input: Tensor, output_mask: StdArray[bool, 3]): tuple[self: Tensor, weight: Tensor, bias: Tensor] {.inline, noinit.} = dynamicCCall("at::thnn_conv2d_backward", grad_output.tensor, self.tensor, weight.tensor, kernel_size, stride, padding, finput.tensor, fgrad_input.tensor, output_mask).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc thnn_conv_depthwise2d*(ty: TensorType; self: Tensor, weight: Tensor, kernel_size: IntList, bias: Tensor, stride: IntList, padding: IntList, dilation: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("thnn_conv_depthwise2d_forward", self.tensor, weight.tensor, kernel_size, bias.tensor, stride, padding, dilation).to(ATensor).newTensor()
proc thnn_conv_depthwise2d*(self: Tensor, weight: Tensor, kernel_size: IntList, bias: Tensor, stride: IntList, padding: IntList, dilation: IntList): Tensor {.inline, noinit.} = dynamicCCall("at::thnn_conv_depthwise2d_forward", self.tensor, weight.tensor, kernel_size, bias.tensor, stride, padding, dilation).to(ATensor).newTensor()
proc thnn_conv_depthwise2d_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, weight: Tensor, kernel_size: IntList, stride: IntList, padding: IntList, dilation: IntList, output_mask: StdArray[bool, 2]): tuple[self: Tensor, weight: Tensor] {.inline, noinit.} = ty.dynamicCppCall("thnn_conv_depthwise2d_backward", grad_output.tensor, self.tensor, weight.tensor, kernel_size, stride, padding, dilation, output_mask).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc thnn_conv_depthwise2d_backward*(grad_output: Tensor, self: Tensor, weight: Tensor, kernel_size: IntList, stride: IntList, padding: IntList, dilation: IntList, output_mask: StdArray[bool, 2]): tuple[self: Tensor, weight: Tensor] {.inline, noinit.} = dynamicCCall("at::thnn_conv_depthwise2d_backward", grad_output.tensor, self.tensor, weight.tensor, kernel_size, stride, padding, dilation, output_mask).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc thnn_conv3d*(ty: TensorType; self: Tensor, weight: Tensor, kernel_size: IntList, bias: Tensor, stride: IntList, padding: IntList): tuple[output: Tensor, finput: Tensor, fgrad_input: Tensor] {.inline, noinit.} = ty.dynamicCppCall("thnn_conv3d_forward", self.tensor, weight.tensor, kernel_size, bias.tensor, stride, padding).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc thnn_conv3d*(self: Tensor, weight: Tensor, kernel_size: IntList, bias: Tensor, stride: IntList, padding: IntList): tuple[output: Tensor, finput: Tensor, fgrad_input: Tensor] {.inline, noinit.} = dynamicCCall("at::thnn_conv3d_forward", self.tensor, weight.tensor, kernel_size, bias.tensor, stride, padding).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc thnn_conv3d_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, weight: Tensor, kernel_size: IntList, stride: IntList, padding: IntList, finput: Tensor, fgrad_input: Tensor, output_mask: StdArray[bool, 3]): tuple[self: Tensor, weight: Tensor, bias: Tensor] {.inline, noinit.} = ty.dynamicCppCall("thnn_conv3d_backward", grad_output.tensor, self.tensor, weight.tensor, kernel_size, stride, padding, finput.tensor, fgrad_input.tensor, output_mask).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc thnn_conv3d_backward*(grad_output: Tensor, self: Tensor, weight: Tensor, kernel_size: IntList, stride: IntList, padding: IntList, finput: Tensor, fgrad_input: Tensor, output_mask: StdArray[bool, 3]): tuple[self: Tensor, weight: Tensor, bias: Tensor] {.inline, noinit.} = dynamicCCall("at::thnn_conv3d_backward", grad_output.tensor, self.tensor, weight.tensor, kernel_size, stride, padding, finput.tensor, fgrad_input.tensor, output_mask).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc thnn_conv_dilated2d*(ty: TensorType; self: Tensor, weight: Tensor, kernel_size: IntList, bias: Tensor, stride: IntList, padding: IntList, dilation: IntList): tuple[output: Tensor, columns: Tensor, ones: Tensor] {.inline, noinit.} = ty.dynamicCppCall("thnn_conv_dilated2d_forward", self.tensor, weight.tensor, kernel_size, bias.tensor, stride, padding, dilation).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc thnn_conv_dilated2d*(self: Tensor, weight: Tensor, kernel_size: IntList, bias: Tensor, stride: IntList, padding: IntList, dilation: IntList): tuple[output: Tensor, columns: Tensor, ones: Tensor] {.inline, noinit.} = dynamicCCall("at::thnn_conv_dilated2d_forward", self.tensor, weight.tensor, kernel_size, bias.tensor, stride, padding, dilation).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc thnn_conv_dilated2d_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, weight: Tensor, kernel_size: IntList, stride: IntList, padding: IntList, dilation: IntList, columns: Tensor, ones: Tensor, output_mask: StdArray[bool, 3]): tuple[self: Tensor, weight: Tensor, bias: Tensor] {.inline, noinit.} = ty.dynamicCppCall("thnn_conv_dilated2d_backward", grad_output.tensor, self.tensor, weight.tensor, kernel_size, stride, padding, dilation, columns.tensor, ones.tensor, output_mask).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc thnn_conv_dilated2d_backward*(grad_output: Tensor, self: Tensor, weight: Tensor, kernel_size: IntList, stride: IntList, padding: IntList, dilation: IntList, columns: Tensor, ones: Tensor, output_mask: StdArray[bool, 3]): tuple[self: Tensor, weight: Tensor, bias: Tensor] {.inline, noinit.} = dynamicCCall("at::thnn_conv_dilated2d_backward", grad_output.tensor, self.tensor, weight.tensor, kernel_size, stride, padding, dilation, columns.tensor, ones.tensor, output_mask).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc thnn_conv_dilated3d*(ty: TensorType; self: Tensor, weight: Tensor, kernel_size: IntList, bias: Tensor, stride: IntList, padding: IntList, dilation: IntList): tuple[output: Tensor, columns: Tensor, ones: Tensor] {.inline, noinit.} = ty.dynamicCppCall("thnn_conv_dilated3d_forward", self.tensor, weight.tensor, kernel_size, bias.tensor, stride, padding, dilation).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc thnn_conv_dilated3d*(self: Tensor, weight: Tensor, kernel_size: IntList, bias: Tensor, stride: IntList, padding: IntList, dilation: IntList): tuple[output: Tensor, columns: Tensor, ones: Tensor] {.inline, noinit.} = dynamicCCall("at::thnn_conv_dilated3d_forward", self.tensor, weight.tensor, kernel_size, bias.tensor, stride, padding, dilation).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc thnn_conv_dilated3d_backward*(ty: TensorType; grad_output: Tensor, self: Tensor, weight: Tensor, kernel_size: IntList, stride: IntList, padding: IntList, dilation: IntList, columns: Tensor, ones: Tensor, output_mask: StdArray[bool, 3]): tuple[self: Tensor, weight: Tensor, bias: Tensor] {.inline, noinit.} = ty.dynamicCppCall("thnn_conv_dilated3d_backward", grad_output.tensor, self.tensor, weight.tensor, kernel_size, stride, padding, dilation, columns.tensor, ones.tensor, output_mask).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc thnn_conv_dilated3d_backward*(grad_output: Tensor, self: Tensor, weight: Tensor, kernel_size: IntList, stride: IntList, padding: IntList, dilation: IntList, columns: Tensor, ones: Tensor, output_mask: StdArray[bool, 3]): tuple[self: Tensor, weight: Tensor, bias: Tensor] {.inline, noinit.} = dynamicCCall("at::thnn_conv_dilated3d_backward", grad_output.tensor, self.tensor, weight.tensor, kernel_size, stride, padding, dilation, columns.tensor, ones.tensor, output_mask).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc u_cast_Byte*(ty: TensorType; self: Tensor, non_blocking: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("_cast_Byte", self.tensor, non_blocking).to(ATensor).newTensor()
proc u_cast_Byte*(self: Tensor, non_blocking: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_cast_Byte", non_blocking).to(ATensor).newTensor()
proc u_cast_Char*(ty: TensorType; self: Tensor, non_blocking: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("_cast_Char", self.tensor, non_blocking).to(ATensor).newTensor()
proc u_cast_Char*(self: Tensor, non_blocking: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_cast_Char", non_blocking).to(ATensor).newTensor()
proc u_cast_Double*(ty: TensorType; self: Tensor, non_blocking: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("_cast_Double", self.tensor, non_blocking).to(ATensor).newTensor()
proc u_cast_Double*(self: Tensor, non_blocking: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_cast_Double", non_blocking).to(ATensor).newTensor()
proc u_cast_Float*(ty: TensorType; self: Tensor, non_blocking: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("_cast_Float", self.tensor, non_blocking).to(ATensor).newTensor()
proc u_cast_Float*(self: Tensor, non_blocking: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_cast_Float", non_blocking).to(ATensor).newTensor()
proc u_cast_Int*(ty: TensorType; self: Tensor, non_blocking: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("_cast_Int", self.tensor, non_blocking).to(ATensor).newTensor()
proc u_cast_Int*(self: Tensor, non_blocking: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_cast_Int", non_blocking).to(ATensor).newTensor()
proc u_cast_Long*(ty: TensorType; self: Tensor, non_blocking: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("_cast_Long", self.tensor, non_blocking).to(ATensor).newTensor()
proc u_cast_Long*(self: Tensor, non_blocking: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_cast_Long", non_blocking).to(ATensor).newTensor()
proc u_cast_Short*(ty: TensorType; self: Tensor, non_blocking: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("_cast_Short", self.tensor, non_blocking).to(ATensor).newTensor()
proc u_cast_Short*(self: Tensor, non_blocking: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_cast_Short", non_blocking).to(ATensor).newTensor()
proc u_cast_Half*(ty: TensorType; self: Tensor, non_blocking: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("_cast_Half", self.tensor, non_blocking).to(ATensor).newTensor()
proc u_cast_Half*(self: Tensor, non_blocking: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_cast_Half", non_blocking).to(ATensor).newTensor()
proc u_cudnn_ctc_loss*(ty: TensorType; log_probs: Tensor, targets: Tensor, input_lengths: IntList, target_lengths: IntList, blank: int64, deterministic: bool): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = ty.dynamicCppCall("_cudnn_ctc_loss", log_probs.tensor, targets.tensor, input_lengths, target_lengths, blank, deterministic).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc u_cudnn_ctc_loss*(log_probs: Tensor, targets: Tensor, input_lengths: IntList, target_lengths: IntList, blank: int64, deterministic: bool): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = dynamicCCall("at::_cudnn_ctc_loss", log_probs.tensor, targets.tensor, input_lengths, target_lengths, blank, deterministic).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc u_cudnn_rnn_flatten_weight*(ty: TensorType; weight_arr: TensorList, weight_stride0: int64, input_size: int64, mode: int64, hidden_size: int64, num_layers: int64, batch_first: bool, bidirectional: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("_cudnn_rnn_flatten_weight", weight_arr, weight_stride0, input_size, mode, hidden_size, num_layers, batch_first, bidirectional).to(ATensor).newTensor()
proc u_cudnn_rnn_flatten_weight*(weight_arr: TensorList, weight_stride0: int64, input_size: int64, mode: int64, hidden_size: int64, num_layers: int64, batch_first: bool, bidirectional: bool): Tensor {.inline, noinit.} = dynamicCCall("at::_cudnn_rnn_flatten_weight", weight_arr, weight_stride0, input_size, mode, hidden_size, num_layers, batch_first, bidirectional).to(ATensor).newTensor()
proc u_cudnn_rnn*(ty: TensorType; input: Tensor, weight: TensorList, weight_stride0: int64, weight_buf: Tensor, hx: Tensor, cx: Tensor, mode: int64, hidden_size: int64, num_layers: int64, batch_first: bool, dropout: float64, train: bool, bidirectional: bool, batch_sizes: IntList, dropout_state: Tensor): tuple[result0: Tensor, result1: Tensor, result2: Tensor, result3: Tensor, result4: Tensor] {.inline, noinit.} = ty.dynamicCppCall("_cudnn_rnn", input.tensor, weight, weight_stride0, weight_buf.tensor, hx.tensor, cx.tensor, mode, hidden_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state.tensor).to(StdTuple5[ATensor, ATensor, ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc u_cudnn_rnn*(input: Tensor, weight: TensorList, weight_stride0: int64, weight_buf: Tensor, hx: Tensor, cx: Tensor, mode: int64, hidden_size: int64, num_layers: int64, batch_first: bool, dropout: float64, train: bool, bidirectional: bool, batch_sizes: IntList, dropout_state: Tensor): tuple[result0: Tensor, result1: Tensor, result2: Tensor, result3: Tensor, result4: Tensor] {.inline, noinit.} = dynamicCCall("at::_cudnn_rnn", input.tensor, weight, weight_stride0, weight_buf.tensor, hx.tensor, cx.tensor, mode, hidden_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state.tensor).to(StdTuple5[ATensor, ATensor, ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc u_cudnn_rnn_backward*(ty: TensorType; input: Tensor, weight: TensorList, weight_stride0: int64, weight_buf: Tensor, hx: Tensor, cx: Tensor, output: Tensor, grad_output: Tensor, grad_hy: Tensor, grad_cy: Tensor, mode: int64, hidden_size: int64, num_layers: int64, batch_first: bool, dropout: float64, train: bool, bidirectional: bool, batch_sizes: IntList, dropout_state: Tensor, reserve: Tensor, output_mask: StdArray[bool, 4]): tuple[result0: Tensor, result1: Tensor, result2: Tensor, result3: TensorList] {.inline, noinit.} = ty.dynamicCppCall("_cudnn_rnn_backward", input.tensor, weight, weight_stride0, weight_buf.tensor, hx.tensor, cx.tensor, output.tensor, grad_output.tensor, grad_hy.tensor, grad_cy.tensor, mode, hidden_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state.tensor, reserve.tensor, output_mask).to(StdTuple4[ATensor, ATensor, ATensor, TensorList]).toNimTuple().newTensors()
proc u_cudnn_rnn_backward*(input: Tensor, weight: TensorList, weight_stride0: int64, weight_buf: Tensor, hx: Tensor, cx: Tensor, output: Tensor, grad_output: Tensor, grad_hy: Tensor, grad_cy: Tensor, mode: int64, hidden_size: int64, num_layers: int64, batch_first: bool, dropout: float64, train: bool, bidirectional: bool, batch_sizes: IntList, dropout_state: Tensor, reserve: Tensor, output_mask: StdArray[bool, 4]): tuple[result0: Tensor, result1: Tensor, result2: Tensor, result3: TensorList] {.inline, noinit.} = dynamicCCall("at::_cudnn_rnn_backward", input.tensor, weight, weight_stride0, weight_buf.tensor, hx.tensor, cx.tensor, output.tensor, grad_output.tensor, grad_hy.tensor, grad_cy.tensor, mode, hidden_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state.tensor, reserve.tensor, output_mask).to(StdTuple4[ATensor, ATensor, ATensor, TensorList]).toNimTuple().newTensors()
proc u_cudnn_init_dropout_state*(ty: TensorType; self_ty: TensorType, dropout: float64, train: bool, dropout_seed: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("_cudnn_init_dropout_state", self_ty, dropout, train, dropout_seed).to(ATensor).newTensor()
proc u_cudnn_init_dropout_state*(self_ty: TensorType, dropout: float64, train: bool, dropout_seed: int64): Tensor {.inline, noinit.} = dynamicCCall("at::_cudnn_init_dropout_state", self_ty, dropout, train, dropout_seed).to(ATensor).newTensor()
proc u_fused_dropout*(ty: TensorType; self: Tensor, p: float64, generator: pointer = nil): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = ty.dynamicCppCall("_fused_dropout", self.tensor, p, generator).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc u_fused_dropout*(self: Tensor, p: float64, generator: pointer = nil): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = self.tensor.dynamicCppCall("_fused_dropout", p, generator).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc u_masked_scale*(ty: TensorType; self: Tensor, mask: Tensor, scale: float64): Tensor {.inline, noinit.} = ty.dynamicCppCall("_masked_scale", self.tensor, mask.tensor, scale).to(ATensor).newTensor()
proc u_masked_scale*(self: Tensor, mask: Tensor, scale: float64): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_masked_scale", mask.tensor, scale).to(ATensor).newTensor()
proc dropout*(ty: TensorType; input: Tensor, p: float64, train: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("dropout", input.tensor, p, train).to(ATensor).newTensor()
proc dropout*(input: Tensor, p: float64, train: bool): Tensor {.inline, noinit.} = dynamicCCall("at::dropout", input.tensor, p, train).to(ATensor).newTensor()
proc dropout_u*(ty: TensorType; self: Tensor, p: float64, train: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("dropout_", self.tensor, p, train).to(ATensor).newTensor()
proc dropout_u*(self: Tensor, p: float64, train: bool): Tensor {.inline, noinit.} = dynamicCCall("at::dropout_", self.tensor, p, train).to(ATensor).newTensor()
proc feature_dropout*(ty: TensorType; input: Tensor, p: float64, train: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("feature_dropout", input.tensor, p, train).to(ATensor).newTensor()
proc feature_dropout*(input: Tensor, p: float64, train: bool): Tensor {.inline, noinit.} = dynamicCCall("at::feature_dropout", input.tensor, p, train).to(ATensor).newTensor()
proc feature_dropout_u*(ty: TensorType; self: Tensor, p: float64, train: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("feature_dropout_", self.tensor, p, train).to(ATensor).newTensor()
proc feature_dropout_u*(self: Tensor, p: float64, train: bool): Tensor {.inline, noinit.} = dynamicCCall("at::feature_dropout_", self.tensor, p, train).to(ATensor).newTensor()
proc alpha_dropout*(ty: TensorType; input: Tensor, p: float64, train: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("alpha_dropout", input.tensor, p, train).to(ATensor).newTensor()
proc alpha_dropout*(input: Tensor, p: float64, train: bool): Tensor {.inline, noinit.} = dynamicCCall("at::alpha_dropout", input.tensor, p, train).to(ATensor).newTensor()
proc alpha_dropout_u*(ty: TensorType; self: Tensor, p: float64, train: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("alpha_dropout_", self.tensor, p, train).to(ATensor).newTensor()
proc alpha_dropout_u*(self: Tensor, p: float64, train: bool): Tensor {.inline, noinit.} = dynamicCCall("at::alpha_dropout_", self.tensor, p, train).to(ATensor).newTensor()
proc feature_alpha_dropout*(ty: TensorType; input: Tensor, p: float64, train: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("feature_alpha_dropout", input.tensor, p, train).to(ATensor).newTensor()
proc feature_alpha_dropout*(input: Tensor, p: float64, train: bool): Tensor {.inline, noinit.} = dynamicCCall("at::feature_alpha_dropout", input.tensor, p, train).to(ATensor).newTensor()
proc feature_alpha_dropout_u*(ty: TensorType; self: Tensor, p: float64, train: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("feature_alpha_dropout_", self.tensor, p, train).to(ATensor).newTensor()
proc feature_alpha_dropout_u*(self: Tensor, p: float64, train: bool): Tensor {.inline, noinit.} = dynamicCCall("at::feature_alpha_dropout_", self.tensor, p, train).to(ATensor).newTensor()
proc abs*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("abs", self.tensor).to(ATensor).newTensor()
proc abs*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("abs").to(ATensor).newTensor()
proc abs_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("abs_", self.tensor).to(ATensor).newTensor()
proc abs_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("abs_").to(ATensor).newTensor()
proc acos*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("acos", self.tensor).to(ATensor).newTensor()
proc acos*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("acos").to(ATensor).newTensor()
proc acos_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("acos_", self.tensor).to(ATensor).newTensor()
proc acos_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("acos_").to(ATensor).newTensor()
proc avg_pool1d*(ty: TensorType; self: Tensor, kernel_size: IntList, stride: IntList, padding: IntList = @[0], ceil_mode: bool = false, count_include_pad: bool = true): Tensor {.inline, noinit.} = ty.dynamicCppCall("avg_pool1d", self.tensor, kernel_size, stride, padding, ceil_mode, count_include_pad).to(ATensor).newTensor()
proc avg_pool1d*(self: Tensor, kernel_size: IntList, stride: IntList, padding: IntList = @[0], ceil_mode: bool = false, count_include_pad: bool = true): Tensor {.inline, noinit.} = dynamicCCall("at::avg_pool1d", self.tensor, kernel_size, stride, padding, ceil_mode, count_include_pad).to(ATensor).newTensor()
proc adaptive_avg_pool1d*(ty: TensorType; self: Tensor, output_size: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("adaptive_avg_pool1d", self.tensor, output_size).to(ATensor).newTensor()
proc adaptive_avg_pool1d*(self: Tensor, output_size: IntList): Tensor {.inline, noinit.} = dynamicCCall("at::adaptive_avg_pool1d", self.tensor, output_size).to(ATensor).newTensor()
proc adaptive_max_pool1d*(ty: TensorType; self: Tensor, output_size: IntList): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = ty.dynamicCppCall("adaptive_max_pool1d", self.tensor, output_size).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc adaptive_max_pool1d*(self: Tensor, output_size: IntList): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = dynamicCCall("at::adaptive_max_pool1d", self.tensor, output_size).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc add*(ty: TensorType; self: Tensor, other: Tensor, alpha: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("add", self.tensor, other.tensor, alpha).to(ATensor).newTensor()
proc add*(self: Tensor, other: Tensor, alpha: float = 1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("add", other.tensor, alpha).to(ATensor).newTensor()
proc add_u*(ty: TensorType; self: Tensor, other: Tensor, alpha: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("add_", self.tensor, other.tensor, alpha).to(ATensor).newTensor()
proc add_u*(self: Tensor, other: Tensor, alpha: float = 1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("add_", other.tensor, alpha).to(ATensor).newTensor()
proc add*(ty: TensorType; self: Tensor, other: float, alpha: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("add", self.tensor, other, alpha).to(ATensor).newTensor()
proc add*(self: Tensor, other: float, alpha: float = 1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("add", other, alpha).to(ATensor).newTensor()
proc add_u*(ty: TensorType; self: Tensor, other: float, alpha: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("add_", self.tensor, other, alpha).to(ATensor).newTensor()
proc add_u*(self: Tensor, other: float, alpha: float = 1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("add_", other, alpha).to(ATensor).newTensor()
proc addmv*(ty: TensorType; self: Tensor, mat: Tensor, vec: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("addmv", self.tensor, mat.tensor, vec.tensor, beta, alpha).to(ATensor).newTensor()
proc addmv*(self: Tensor, mat: Tensor, vec: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("addmv", mat.tensor, vec.tensor, beta, alpha).to(ATensor).newTensor()
proc addmv_u*(ty: TensorType; self: Tensor, mat: Tensor, vec: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("addmv_", self.tensor, mat.tensor, vec.tensor, beta, alpha).to(ATensor).newTensor()
proc addmv_u*(self: Tensor, mat: Tensor, vec: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("addmv_", mat.tensor, vec.tensor, beta, alpha).to(ATensor).newTensor()
proc addr*(ty: TensorType; self: Tensor, vec1: Tensor, vec2: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("addr", self.tensor, vec1.tensor, vec2.tensor, beta, alpha).to(ATensor).newTensor()
proc addr*(self: Tensor, vec1: Tensor, vec2: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("addr", vec1.tensor, vec2.tensor, beta, alpha).to(ATensor).newTensor()
proc addr_u*(ty: TensorType; self: Tensor, vec1: Tensor, vec2: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("addr_", self.tensor, vec1.tensor, vec2.tensor, beta, alpha).to(ATensor).newTensor()
proc addr_u*(self: Tensor, vec1: Tensor, vec2: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("addr_", vec1.tensor, vec2.tensor, beta, alpha).to(ATensor).newTensor()
proc all*(ty: TensorType; self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("all", self.tensor, dim, keepdim).to(ATensor).newTensor()
proc all*(self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("all", dim, keepdim).to(ATensor).newTensor()
proc allclose*(ty: TensorType; self: Tensor, other: Tensor, rtol: float64, atol: float64, equal_nan: bool = false): bool {.inline, noinit.} = ty.dynamicCppCall("allclose", self.tensor, other.tensor, rtol, atol, equal_nan).to(bool)
proc allclose*(self: Tensor, other: Tensor, rtol: float64, atol: float64, equal_nan: bool = false): bool {.inline, noinit.} = self.tensor.dynamicCppCall("allclose", other.tensor, rtol, atol, equal_nan).to(bool)
proc any*(ty: TensorType; self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("any", self.tensor, dim, keepdim).to(ATensor).newTensor()
proc any*(self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("any", dim, keepdim).to(ATensor).newTensor()
proc arange*(ty: TensorType; start: float, aend: float, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("arange", start, aend, options).to(ATensor).newTensor()
proc arange*(start: float, aend: float, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::arange", start, aend, options).to(ATensor).newTensor()
proc arange*(ty: TensorType; start: float, aend: float, step: float, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("arange", start, aend, step, options).to(ATensor).newTensor()
proc arange*(start: float, aend: float, step: float, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::arange", start, aend, step, options).to(ATensor).newTensor()
proc arange*(ty: TensorType; aend: float, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("arange", aend, options).to(ATensor).newTensor()
proc arange*(aend: float, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::arange", aend, options).to(ATensor).newTensor()
proc u_dim_arange*(ty: TensorType; like: Tensor, dim: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("_dim_arange", like.tensor, dim).to(ATensor).newTensor()
proc u_dim_arange*(like: Tensor, dim: int64): Tensor {.inline, noinit.} = dynamicCCall("at::_dim_arange", like.tensor, dim).to(ATensor).newTensor()
proc argmax*(ty: TensorType; self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("argmax", self.tensor, dim, keepdim).to(ATensor).newTensor()
proc argmax*(self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("argmax", dim, keepdim).to(ATensor).newTensor()
proc argmax*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("argmax", self.tensor).to(ATensor).newTensor()
proc argmax*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("argmax").to(ATensor).newTensor()
proc u_argmax*(ty: TensorType; self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("_argmax", self.tensor, dim, keepdim).to(ATensor).newTensor()
proc u_argmax*(self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_argmax", dim, keepdim).to(ATensor).newTensor()
proc argmin*(ty: TensorType; self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("argmin", self.tensor, dim, keepdim).to(ATensor).newTensor()
proc argmin*(self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("argmin", dim, keepdim).to(ATensor).newTensor()
proc argmin*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("argmin", self.tensor).to(ATensor).newTensor()
proc argmin*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("argmin").to(ATensor).newTensor()
proc u_argmin*(ty: TensorType; self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("_argmin", self.tensor, dim, keepdim).to(ATensor).newTensor()
proc u_argmin*(self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_argmin", dim, keepdim).to(ATensor).newTensor()
proc as_strided*(ty: TensorType; self: Tensor, size: IntList, stride: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("as_strided", self.tensor, size, stride).to(ATensor).newTensor()
proc as_strided*(self: Tensor, size: IntList, stride: IntList): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("as_strided", size, stride).to(ATensor).newTensor()
proc as_strided_u*(ty: TensorType; self: Tensor, size: IntList, stride: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("as_strided_", self.tensor, size, stride).to(ATensor).newTensor()
proc as_strided_u*(self: Tensor, size: IntList, stride: IntList): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("as_strided_", size, stride).to(ATensor).newTensor()
proc as_strided*(ty: TensorType; self: Tensor, size: IntList, stride: IntList, storage_offset: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("as_strided", self.tensor, size, stride, storage_offset).to(ATensor).newTensor()
proc as_strided*(self: Tensor, size: IntList, stride: IntList, storage_offset: int64): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("as_strided", size, stride, storage_offset).to(ATensor).newTensor()
proc as_strided_u*(ty: TensorType; self: Tensor, size: IntList, stride: IntList, storage_offset: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("as_strided_", self.tensor, size, stride, storage_offset).to(ATensor).newTensor()
proc as_strided_u*(self: Tensor, size: IntList, stride: IntList, storage_offset: int64): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("as_strided_", size, stride, storage_offset).to(ATensor).newTensor()
proc asin*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("asin", self.tensor).to(ATensor).newTensor()
proc asin*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("asin").to(ATensor).newTensor()
proc asin_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("asin_", self.tensor).to(ATensor).newTensor()
proc asin_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("asin_").to(ATensor).newTensor()
proc atan*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("atan", self.tensor).to(ATensor).newTensor()
proc atan*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("atan").to(ATensor).newTensor()
proc atan_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("atan_", self.tensor).to(ATensor).newTensor()
proc atan_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("atan_").to(ATensor).newTensor()
proc bartlett_window*(ty: TensorType; window_length: int64, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("bartlett_window", window_length, options).to(ATensor).newTensor()
proc bartlett_window*(window_length: int64, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::bartlett_window", window_length, options).to(ATensor).newTensor()
proc bartlett_window*(ty: TensorType; window_length: int64, periodic: bool, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("bartlett_window", window_length, periodic, options).to(ATensor).newTensor()
proc bartlett_window*(window_length: int64, periodic: bool, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::bartlett_window", window_length, periodic, options).to(ATensor).newTensor()
proc batch_norm*(ty: TensorType; input: Tensor, weight: Tensor, bias: Tensor, running_mean: Tensor, running_var: Tensor, training: bool, momentum: float64, eps: float64, cudnn_enabled: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("batch_norm", input.tensor, weight.tensor, bias.tensor, running_mean.tensor, running_var.tensor, training, momentum, eps, cudnn_enabled).to(ATensor).newTensor()
proc batch_norm*(input: Tensor, weight: Tensor, bias: Tensor, running_mean: Tensor, running_var: Tensor, training: bool, momentum: float64, eps: float64, cudnn_enabled: bool): Tensor {.inline, noinit.} = dynamicCCall("at::batch_norm", input.tensor, weight.tensor, bias.tensor, running_mean.tensor, running_var.tensor, training, momentum, eps, cudnn_enabled).to(ATensor).newTensor()
proc bernoulli*(ty: TensorType; self: Tensor, p: Tensor, generator: pointer = nil): Tensor {.inline, noinit.} = ty.dynamicCppCall("bernoulli", self.tensor, p.tensor, generator).to(ATensor).newTensor()
proc bernoulli*(self: Tensor, p: Tensor, generator: pointer = nil): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("bernoulli", p.tensor, generator).to(ATensor).newTensor()
proc bernoulli*(ty: TensorType; self: Tensor, p: float64, generator: pointer = nil): Tensor {.inline, noinit.} = ty.dynamicCppCall("bernoulli", self.tensor, p, generator).to(ATensor).newTensor()
proc bernoulli*(self: Tensor, p: float64, generator: pointer = nil): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("bernoulli", p, generator).to(ATensor).newTensor()
proc bernoulli*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("bernoulli", self.tensor).to(ATensor).newTensor()
proc bernoulli*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("bernoulli").to(ATensor).newTensor()
proc bernoulli_u*(ty: TensorType; self: Tensor, p: Tensor, generator: pointer = nil): Tensor {.inline, noinit.} = ty.dynamicCppCall("bernoulli_", self.tensor, p.tensor, generator).to(ATensor).newTensor()
proc bernoulli_u*(self: Tensor, p: Tensor, generator: pointer = nil): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("bernoulli_", p.tensor, generator).to(ATensor).newTensor()
proc bernoulli_u*(ty: TensorType; self: Tensor, p: float64, generator: pointer = nil): Tensor {.inline, noinit.} = ty.dynamicCppCall("bernoulli_", self.tensor, p, generator).to(ATensor).newTensor()
proc bernoulli_u*(self: Tensor, p: float64, generator: pointer = nil): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("bernoulli_", p, generator).to(ATensor).newTensor()
proc bernoulli_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("bernoulli_", self.tensor).to(ATensor).newTensor()
proc bernoulli_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("bernoulli_").to(ATensor).newTensor()
proc bilinear*(ty: TensorType; input1: Tensor, input2: Tensor, weight: Tensor, bias: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("bilinear", input1.tensor, input2.tensor, weight.tensor, bias.tensor).to(ATensor).newTensor()
proc bilinear*(input1: Tensor, input2: Tensor, weight: Tensor, bias: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::bilinear", input1.tensor, input2.tensor, weight.tensor, bias.tensor).to(ATensor).newTensor()
proc bincount*(ty: TensorType; self: Tensor, weights: Tensor, minlength: int64 = 0): Tensor {.inline, noinit.} = ty.dynamicCppCall("bincount", self.tensor, weights.tensor, minlength).to(ATensor).newTensor()
proc bincount*(self: Tensor, weights: Tensor, minlength: int64 = 0): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("bincount", weights.tensor, minlength).to(ATensor).newTensor()
proc blackman_window*(ty: TensorType; window_length: int64, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("blackman_window", window_length, options).to(ATensor).newTensor()
proc blackman_window*(window_length: int64, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::blackman_window", window_length, options).to(ATensor).newTensor()
proc blackman_window*(ty: TensorType; window_length: int64, periodic: bool, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("blackman_window", window_length, periodic, options).to(ATensor).newTensor()
proc blackman_window*(window_length: int64, periodic: bool, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::blackman_window", window_length, periodic, options).to(ATensor).newTensor()
proc broadcast_tensors*(ty: TensorType; tensors: TensorList): TensorList {.inline, noinit.} = ty.dynamicCppCall("broadcast_tensors", tensors).to(TensorList)
proc broadcast_tensors*(tensors: TensorList): TensorList {.inline, noinit.} = dynamicCCall("at::broadcast_tensors", tensors).to(TensorList)
proc cat*(ty: TensorType; tensors: TensorList, dim: int64 = 0): Tensor {.inline, noinit.} = ty.dynamicCppCall("cat", tensors, dim).to(ATensor).newTensor()
proc cat*(tensors: TensorList, dim: int64 = 0): Tensor {.inline, noinit.} = dynamicCCall("at::cat", tensors, dim).to(ATensor).newTensor()
proc ceil*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("ceil", self.tensor).to(ATensor).newTensor()
proc ceil*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("ceil").to(ATensor).newTensor()
proc ceil_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("ceil_", self.tensor).to(ATensor).newTensor()
proc ceil_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("ceil_").to(ATensor).newTensor()
proc chunk*(ty: TensorType; self: Tensor, chunks: int64, dim: int64 = 0): TensorList {.inline, noinit.} = ty.dynamicCppCall("chunk", self.tensor, chunks, dim).to(TensorList)
proc chunk*(self: Tensor, chunks: int64, dim: int64 = 0): TensorList {.inline, noinit.} = self.tensor.dynamicCppCall("chunk", chunks, dim).to(TensorList)
proc clamp*(ty: TensorType; self: Tensor, min: float, max: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("clamp", self.tensor, min, max).to(ATensor).newTensor()
proc clamp*(self: Tensor, min: float, max: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("clamp", min, max).to(ATensor).newTensor()
proc clamp_u*(ty: TensorType; self: Tensor, min: float, max: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("clamp_", self.tensor, min, max).to(ATensor).newTensor()
proc clamp_u*(self: Tensor, min: float, max: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("clamp_", min, max).to(ATensor).newTensor()
proc clamp_max*(ty: TensorType; self: Tensor, max: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("clamp_max", self.tensor, max).to(ATensor).newTensor()
proc clamp_max*(self: Tensor, max: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("clamp_max", max).to(ATensor).newTensor()
proc clamp_max_u*(ty: TensorType; self: Tensor, max: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("clamp_max_", self.tensor, max).to(ATensor).newTensor()
proc clamp_max_u*(self: Tensor, max: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("clamp_max_", max).to(ATensor).newTensor()
proc clamp_min*(ty: TensorType; self: Tensor, min: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("clamp_min", self.tensor, min).to(ATensor).newTensor()
proc clamp_min*(self: Tensor, min: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("clamp_min", min).to(ATensor).newTensor()
proc clamp_min_u*(ty: TensorType; self: Tensor, min: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("clamp_min_", self.tensor, min).to(ATensor).newTensor()
proc clamp_min_u*(self: Tensor, min: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("clamp_min_", min).to(ATensor).newTensor()
proc cudnn_is_acceptable*(ty: TensorType; self: Tensor): bool {.inline, noinit.} = ty.dynamicCppCall("cudnn_is_acceptable", self.tensor).to(bool)
proc cudnn_is_acceptable*(self: Tensor): bool {.inline, noinit.} = dynamicCCall("at::cudnn_is_acceptable", self.tensor).to(bool)
proc convolution*(ty: TensorType; input: Tensor, weight: Tensor, bias: Tensor, stride: IntList, padding: IntList, dilation: IntList, transposed: bool, output_padding: IntList, groups: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("convolution", input.tensor, weight.tensor, bias.tensor, stride, padding, dilation, transposed, output_padding, groups).to(ATensor).newTensor()
proc convolution*(input: Tensor, weight: Tensor, bias: Tensor, stride: IntList, padding: IntList, dilation: IntList, transposed: bool, output_padding: IntList, groups: int64): Tensor {.inline, noinit.} = dynamicCCall("at::convolution", input.tensor, weight.tensor, bias.tensor, stride, padding, dilation, transposed, output_padding, groups).to(ATensor).newTensor()
proc u_convolution*(ty: TensorType; input: Tensor, weight: Tensor, bias: Tensor, stride: IntList, padding: IntList, dilation: IntList, transposed: bool, output_padding: IntList, groups: int64, benchmark: bool, deterministic: bool, cudnn_enabled: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("_convolution", input.tensor, weight.tensor, bias.tensor, stride, padding, dilation, transposed, output_padding, groups, benchmark, deterministic, cudnn_enabled).to(ATensor).newTensor()
proc u_convolution*(input: Tensor, weight: Tensor, bias: Tensor, stride: IntList, padding: IntList, dilation: IntList, transposed: bool, output_padding: IntList, groups: int64, benchmark: bool, deterministic: bool, cudnn_enabled: bool): Tensor {.inline, noinit.} = dynamicCCall("at::_convolution", input.tensor, weight.tensor, bias.tensor, stride, padding, dilation, transposed, output_padding, groups, benchmark, deterministic, cudnn_enabled).to(ATensor).newTensor()
proc u_convolution_nogroup*(ty: TensorType; input: Tensor, weight: Tensor, bias: Tensor, stride: IntList, padding: IntList, dilation: IntList, transposed: bool, output_padding: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("_convolution_nogroup", input.tensor, weight.tensor, bias.tensor, stride, padding, dilation, transposed, output_padding).to(ATensor).newTensor()
proc u_convolution_nogroup*(input: Tensor, weight: Tensor, bias: Tensor, stride: IntList, padding: IntList, dilation: IntList, transposed: bool, output_padding: IntList): Tensor {.inline, noinit.} = dynamicCCall("at::_convolution_nogroup", input.tensor, weight.tensor, bias.tensor, stride, padding, dilation, transposed, output_padding).to(ATensor).newTensor()
proc u_convolution_double_backward*(ty: TensorType; ggI: Tensor, ggW: Tensor, ggb: Tensor, gO: Tensor, weight: Tensor, self: Tensor, stride: IntList, padding: IntList, dilation: IntList, transposed: bool, output_padding: IntList, groups: int64, benchmark: bool, deterministic: bool, cudnn_enabled: bool, output_mask: StdArray[bool, 3]): tuple[result0: Tensor, result1: Tensor, result2: Tensor] {.inline, noinit.} = ty.dynamicCppCall("_convolution_double_backward", ggI.tensor, ggW.tensor, ggb.tensor, gO.tensor, weight.tensor, self.tensor, stride, padding, dilation, transposed, output_padding, groups, benchmark, deterministic, cudnn_enabled, output_mask).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc u_convolution_double_backward*(ggI: Tensor, ggW: Tensor, ggb: Tensor, gO: Tensor, weight: Tensor, self: Tensor, stride: IntList, padding: IntList, dilation: IntList, transposed: bool, output_padding: IntList, groups: int64, benchmark: bool, deterministic: bool, cudnn_enabled: bool, output_mask: StdArray[bool, 3]): tuple[result0: Tensor, result1: Tensor, result2: Tensor] {.inline, noinit.} = dynamicCCall("at::_convolution_double_backward", ggI.tensor, ggW.tensor, ggb.tensor, gO.tensor, weight.tensor, self.tensor, stride, padding, dilation, transposed, output_padding, groups, benchmark, deterministic, cudnn_enabled, output_mask).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc conv1d*(ty: TensorType; input: Tensor, weight: Tensor, bias: Tensor, stride: IntList = @[1], padding: IntList = @[0], dilation: IntList = @[1], groups: int64 = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("conv1d", input.tensor, weight.tensor, bias.tensor, stride, padding, dilation, groups).to(ATensor).newTensor()
proc conv1d*(input: Tensor, weight: Tensor, bias: Tensor, stride: IntList = @[1], padding: IntList = @[0], dilation: IntList = @[1], groups: int64 = 1): Tensor {.inline, noinit.} = dynamicCCall("at::conv1d", input.tensor, weight.tensor, bias.tensor, stride, padding, dilation, groups).to(ATensor).newTensor()
proc conv2d*(ty: TensorType; input: Tensor, weight: Tensor, bias: Tensor, stride: IntList = @[1], padding: IntList = @[0], dilation: IntList = @[1], groups: int64 = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("conv2d", input.tensor, weight.tensor, bias.tensor, stride, padding, dilation, groups).to(ATensor).newTensor()
proc conv2d*(input: Tensor, weight: Tensor, bias: Tensor, stride: IntList = @[1], padding: IntList = @[0], dilation: IntList = @[1], groups: int64 = 1): Tensor {.inline, noinit.} = dynamicCCall("at::conv2d", input.tensor, weight.tensor, bias.tensor, stride, padding, dilation, groups).to(ATensor).newTensor()
proc conv3d*(ty: TensorType; input: Tensor, weight: Tensor, bias: Tensor, stride: IntList = @[1], padding: IntList = @[0], dilation: IntList = @[1], groups: int64 = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("conv3d", input.tensor, weight.tensor, bias.tensor, stride, padding, dilation, groups).to(ATensor).newTensor()
proc conv3d*(input: Tensor, weight: Tensor, bias: Tensor, stride: IntList = @[1], padding: IntList = @[0], dilation: IntList = @[1], groups: int64 = 1): Tensor {.inline, noinit.} = dynamicCCall("at::conv3d", input.tensor, weight.tensor, bias.tensor, stride, padding, dilation, groups).to(ATensor).newTensor()
proc conv_tbc*(ty: TensorType; self: Tensor, weight: Tensor, bias: Tensor, pad: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("conv_tbc", self.tensor, weight.tensor, bias.tensor, pad).to(ATensor).newTensor()
proc conv_tbc*(self: Tensor, weight: Tensor, bias: Tensor, pad: int64): Tensor {.inline, noinit.} = dynamicCCall("at::conv_tbc", self.tensor, weight.tensor, bias.tensor, pad).to(ATensor).newTensor()
proc conv_tbc_backward*(ty: TensorType; self: Tensor, input: Tensor, weight: Tensor, bias: Tensor, pad: int64): tuple[result0: Tensor, result1: Tensor, result2: Tensor] {.inline, noinit.} = ty.dynamicCppCall("conv_tbc_backward", self.tensor, input.tensor, weight.tensor, bias.tensor, pad).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc conv_tbc_backward*(self: Tensor, input: Tensor, weight: Tensor, bias: Tensor, pad: int64): tuple[result0: Tensor, result1: Tensor, result2: Tensor] {.inline, noinit.} = dynamicCCall("at::conv_tbc_backward", self.tensor, input.tensor, weight.tensor, bias.tensor, pad).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc conv_transpose1d*(ty: TensorType; input: Tensor, weight: Tensor, bias: Tensor, stride: IntList = @[1], padding: IntList = @[0], output_padding: IntList = @[0], groups: int64 = 1, dilation: IntList = @[1]): Tensor {.inline, noinit.} = ty.dynamicCppCall("conv_transpose1d", input.tensor, weight.tensor, bias.tensor, stride, padding, output_padding, groups, dilation).to(ATensor).newTensor()
proc conv_transpose1d*(input: Tensor, weight: Tensor, bias: Tensor, stride: IntList = @[1], padding: IntList = @[0], output_padding: IntList = @[0], groups: int64 = 1, dilation: IntList = @[1]): Tensor {.inline, noinit.} = dynamicCCall("at::conv_transpose1d", input.tensor, weight.tensor, bias.tensor, stride, padding, output_padding, groups, dilation).to(ATensor).newTensor()
proc conv_transpose2d*(ty: TensorType; input: Tensor, weight: Tensor, bias: Tensor, stride: IntList = @[1], padding: IntList = @[0], output_padding: IntList = @[0], groups: int64 = 1, dilation: IntList = @[1]): Tensor {.inline, noinit.} = ty.dynamicCppCall("conv_transpose2d", input.tensor, weight.tensor, bias.tensor, stride, padding, output_padding, groups, dilation).to(ATensor).newTensor()
proc conv_transpose2d*(input: Tensor, weight: Tensor, bias: Tensor, stride: IntList = @[1], padding: IntList = @[0], output_padding: IntList = @[0], groups: int64 = 1, dilation: IntList = @[1]): Tensor {.inline, noinit.} = dynamicCCall("at::conv_transpose2d", input.tensor, weight.tensor, bias.tensor, stride, padding, output_padding, groups, dilation).to(ATensor).newTensor()
proc conv_transpose3d*(ty: TensorType; input: Tensor, weight: Tensor, bias: Tensor, stride: IntList = @[1], padding: IntList = @[0], output_padding: IntList = @[0], groups: int64 = 1, dilation: IntList = @[1]): Tensor {.inline, noinit.} = ty.dynamicCppCall("conv_transpose3d", input.tensor, weight.tensor, bias.tensor, stride, padding, output_padding, groups, dilation).to(ATensor).newTensor()
proc conv_transpose3d*(input: Tensor, weight: Tensor, bias: Tensor, stride: IntList = @[1], padding: IntList = @[0], output_padding: IntList = @[0], groups: int64 = 1, dilation: IntList = @[1]): Tensor {.inline, noinit.} = dynamicCCall("at::conv_transpose3d", input.tensor, weight.tensor, bias.tensor, stride, padding, output_padding, groups, dilation).to(ATensor).newTensor()
proc cos*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("cos", self.tensor).to(ATensor).newTensor()
proc cos*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("cos").to(ATensor).newTensor()
proc cos_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("cos_", self.tensor).to(ATensor).newTensor()
proc cos_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("cos_").to(ATensor).newTensor()
proc cosh*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("cosh", self.tensor).to(ATensor).newTensor()
proc cosh*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("cosh").to(ATensor).newTensor()
proc cosh_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("cosh_", self.tensor).to(ATensor).newTensor()
proc cosh_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("cosh_").to(ATensor).newTensor()
proc cosine_embedding_loss*(ty: TensorType; input1: Tensor, input2: Tensor, target: Tensor, margin: float64, reduction: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("cosine_embedding_loss", input1.tensor, input2.tensor, target.tensor, margin, reduction).to(ATensor).newTensor()
proc cosine_embedding_loss*(input1: Tensor, input2: Tensor, target: Tensor, margin: float64, reduction: int64): Tensor {.inline, noinit.} = dynamicCCall("at::cosine_embedding_loss", input1.tensor, input2.tensor, target.tensor, margin, reduction).to(ATensor).newTensor()
proc cudnn_affine_grid_generator*(ty: TensorType; theta: Tensor, N: int64, C: int64, H: int64, W: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("cudnn_affine_grid_generator", theta.tensor, N, C, H, W).to(ATensor).newTensor()
proc cudnn_affine_grid_generator*(theta: Tensor, N: int64, C: int64, H: int64, W: int64): Tensor {.inline, noinit.} = dynamicCCall("at::cudnn_affine_grid_generator", theta.tensor, N, C, H, W).to(ATensor).newTensor()
proc cudnn_affine_grid_generator_backward*(ty: TensorType; grad: Tensor, N: int64, C: int64, H: int64, W: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("cudnn_affine_grid_generator_backward", grad.tensor, N, C, H, W).to(ATensor).newTensor()
proc cudnn_affine_grid_generator_backward*(grad: Tensor, N: int64, C: int64, H: int64, W: int64): Tensor {.inline, noinit.} = dynamicCCall("at::cudnn_affine_grid_generator_backward", grad.tensor, N, C, H, W).to(ATensor).newTensor()
proc cudnn_batch_norm*(ty: TensorType; input: Tensor, weight: Tensor, bias: Tensor, running_mean: Tensor, running_var: Tensor, training: bool, exponential_average_factor: float64, epsilon: float64): tuple[result0: Tensor, result1: Tensor, result2: Tensor] {.inline, noinit.} = ty.dynamicCppCall("cudnn_batch_norm", input.tensor, weight.tensor, bias.tensor, running_mean.tensor, running_var.tensor, training, exponential_average_factor, epsilon).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc cudnn_batch_norm*(input: Tensor, weight: Tensor, bias: Tensor, running_mean: Tensor, running_var: Tensor, training: bool, exponential_average_factor: float64, epsilon: float64): tuple[result0: Tensor, result1: Tensor, result2: Tensor] {.inline, noinit.} = dynamicCCall("at::cudnn_batch_norm", input.tensor, weight.tensor, bias.tensor, running_mean.tensor, running_var.tensor, training, exponential_average_factor, epsilon).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc cudnn_batch_norm_backward*(ty: TensorType; input: Tensor, grad_output: Tensor, weight: Tensor, running_mean: Tensor, running_var: Tensor, save_mean: Tensor, save_var: Tensor, epsilon: float64): tuple[result0: Tensor, result1: Tensor, result2: Tensor] {.inline, noinit.} = ty.dynamicCppCall("cudnn_batch_norm_backward", input.tensor, grad_output.tensor, weight.tensor, running_mean.tensor, running_var.tensor, save_mean.tensor, save_var.tensor, epsilon).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc cudnn_batch_norm_backward*(input: Tensor, grad_output: Tensor, weight: Tensor, running_mean: Tensor, running_var: Tensor, save_mean: Tensor, save_var: Tensor, epsilon: float64): tuple[result0: Tensor, result1: Tensor, result2: Tensor] {.inline, noinit.} = dynamicCCall("at::cudnn_batch_norm_backward", input.tensor, grad_output.tensor, weight.tensor, running_mean.tensor, running_var.tensor, save_mean.tensor, save_var.tensor, epsilon).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc cudnn_convolution*(ty: TensorType; self: Tensor, weight: Tensor, bias: Tensor, padding: IntList, stride: IntList, dilation: IntList, groups: int64, benchmark: bool, deterministic: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("cudnn_convolution", self.tensor, weight.tensor, bias.tensor, padding, stride, dilation, groups, benchmark, deterministic).to(ATensor).newTensor()
proc cudnn_convolution*(self: Tensor, weight: Tensor, bias: Tensor, padding: IntList, stride: IntList, dilation: IntList, groups: int64, benchmark: bool, deterministic: bool): Tensor {.inline, noinit.} = dynamicCCall("at::cudnn_convolution", self.tensor, weight.tensor, bias.tensor, padding, stride, dilation, groups, benchmark, deterministic).to(ATensor).newTensor()
proc cudnn_convolution_backward_input*(ty: TensorType; self_size: IntList, grad_output: Tensor, weight: Tensor, padding: IntList, stride: IntList, dilation: IntList, groups: int64, benchmark: bool, deterministic: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("cudnn_convolution_backward_input", self_size, grad_output.tensor, weight.tensor, padding, stride, dilation, groups, benchmark, deterministic).to(ATensor).newTensor()
proc cudnn_convolution_backward_input*(self_size: IntList, grad_output: Tensor, weight: Tensor, padding: IntList, stride: IntList, dilation: IntList, groups: int64, benchmark: bool, deterministic: bool): Tensor {.inline, noinit.} = dynamicCCall("at::cudnn_convolution_backward_input", self_size, grad_output.tensor, weight.tensor, padding, stride, dilation, groups, benchmark, deterministic).to(ATensor).newTensor()
proc cudnn_convolution_backward*(ty: TensorType; self: Tensor, grad_output: Tensor, weight: Tensor, padding: IntList, stride: IntList, dilation: IntList, groups: int64, benchmark: bool, deterministic: bool, output_mask: StdArray[bool, 3]): tuple[result0: Tensor, result1: Tensor, result2: Tensor] {.inline, noinit.} = ty.dynamicCppCall("cudnn_convolution_backward", self.tensor, grad_output.tensor, weight.tensor, padding, stride, dilation, groups, benchmark, deterministic, output_mask).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc cudnn_convolution_backward*(self: Tensor, grad_output: Tensor, weight: Tensor, padding: IntList, stride: IntList, dilation: IntList, groups: int64, benchmark: bool, deterministic: bool, output_mask: StdArray[bool, 3]): tuple[result0: Tensor, result1: Tensor, result2: Tensor] {.inline, noinit.} = dynamicCCall("at::cudnn_convolution_backward", self.tensor, grad_output.tensor, weight.tensor, padding, stride, dilation, groups, benchmark, deterministic, output_mask).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc cudnn_convolution_backward_bias*(ty: TensorType; grad_output: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("cudnn_convolution_backward_bias", grad_output.tensor).to(ATensor).newTensor()
proc cudnn_convolution_backward_bias*(grad_output: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::cudnn_convolution_backward_bias", grad_output.tensor).to(ATensor).newTensor()
proc cudnn_convolution_backward_weight*(ty: TensorType; weight_size: IntList, grad_output: Tensor, self: Tensor, padding: IntList, stride: IntList, dilation: IntList, groups: int64, benchmark: bool, deterministic: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("cudnn_convolution_backward_weight", weight_size, grad_output.tensor, self.tensor, padding, stride, dilation, groups, benchmark, deterministic).to(ATensor).newTensor()
proc cudnn_convolution_backward_weight*(weight_size: IntList, grad_output: Tensor, self: Tensor, padding: IntList, stride: IntList, dilation: IntList, groups: int64, benchmark: bool, deterministic: bool): Tensor {.inline, noinit.} = dynamicCCall("at::cudnn_convolution_backward_weight", weight_size, grad_output.tensor, self.tensor, padding, stride, dilation, groups, benchmark, deterministic).to(ATensor).newTensor()
proc cudnn_convolution_transpose*(ty: TensorType; self: Tensor, weight: Tensor, bias: Tensor, padding: IntList, output_padding: IntList, stride: IntList, dilation: IntList, groups: int64, benchmark: bool, deterministic: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("cudnn_convolution_transpose", self.tensor, weight.tensor, bias.tensor, padding, output_padding, stride, dilation, groups, benchmark, deterministic).to(ATensor).newTensor()
proc cudnn_convolution_transpose*(self: Tensor, weight: Tensor, bias: Tensor, padding: IntList, output_padding: IntList, stride: IntList, dilation: IntList, groups: int64, benchmark: bool, deterministic: bool): Tensor {.inline, noinit.} = dynamicCCall("at::cudnn_convolution_transpose", self.tensor, weight.tensor, bias.tensor, padding, output_padding, stride, dilation, groups, benchmark, deterministic).to(ATensor).newTensor()
proc cudnn_convolution_transpose_backward*(ty: TensorType; self: Tensor, grad_output: Tensor, weight: Tensor, padding: IntList, output_padding: IntList, stride: IntList, dilation: IntList, groups: int64, benchmark: bool, deterministic: bool, output_mask: StdArray[bool, 3]): tuple[result0: Tensor, result1: Tensor, result2: Tensor] {.inline, noinit.} = ty.dynamicCppCall("cudnn_convolution_transpose_backward", self.tensor, grad_output.tensor, weight.tensor, padding, output_padding, stride, dilation, groups, benchmark, deterministic, output_mask).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc cudnn_convolution_transpose_backward*(self: Tensor, grad_output: Tensor, weight: Tensor, padding: IntList, output_padding: IntList, stride: IntList, dilation: IntList, groups: int64, benchmark: bool, deterministic: bool, output_mask: StdArray[bool, 3]): tuple[result0: Tensor, result1: Tensor, result2: Tensor] {.inline, noinit.} = dynamicCCall("at::cudnn_convolution_transpose_backward", self.tensor, grad_output.tensor, weight.tensor, padding, output_padding, stride, dilation, groups, benchmark, deterministic, output_mask).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc cudnn_convolution_transpose_backward_bias*(ty: TensorType; grad_output: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("cudnn_convolution_transpose_backward_bias", grad_output.tensor).to(ATensor).newTensor()
proc cudnn_convolution_transpose_backward_bias*(grad_output: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::cudnn_convolution_transpose_backward_bias", grad_output.tensor).to(ATensor).newTensor()
proc cudnn_convolution_transpose_backward_input*(ty: TensorType; grad_output: Tensor, weight: Tensor, padding: IntList, stride: IntList, dilation: IntList, groups: int64, benchmark: bool, deterministic: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("cudnn_convolution_transpose_backward_input", grad_output.tensor, weight.tensor, padding, stride, dilation, groups, benchmark, deterministic).to(ATensor).newTensor()
proc cudnn_convolution_transpose_backward_input*(grad_output: Tensor, weight: Tensor, padding: IntList, stride: IntList, dilation: IntList, groups: int64, benchmark: bool, deterministic: bool): Tensor {.inline, noinit.} = dynamicCCall("at::cudnn_convolution_transpose_backward_input", grad_output.tensor, weight.tensor, padding, stride, dilation, groups, benchmark, deterministic).to(ATensor).newTensor()
proc cudnn_convolution_transpose_backward_weight*(ty: TensorType; weight_size: IntList, grad_output: Tensor, self: Tensor, padding: IntList, stride: IntList, dilation: IntList, groups: int64, benchmark: bool, deterministic: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("cudnn_convolution_transpose_backward_weight", weight_size, grad_output.tensor, self.tensor, padding, stride, dilation, groups, benchmark, deterministic).to(ATensor).newTensor()
proc cudnn_convolution_transpose_backward_weight*(weight_size: IntList, grad_output: Tensor, self: Tensor, padding: IntList, stride: IntList, dilation: IntList, groups: int64, benchmark: bool, deterministic: bool): Tensor {.inline, noinit.} = dynamicCCall("at::cudnn_convolution_transpose_backward_weight", weight_size, grad_output.tensor, self.tensor, padding, stride, dilation, groups, benchmark, deterministic).to(ATensor).newTensor()
proc cudnn_grid_sampler*(ty: TensorType; self: Tensor, grid: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("cudnn_grid_sampler", self.tensor, grid.tensor).to(ATensor).newTensor()
proc cudnn_grid_sampler*(self: Tensor, grid: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::cudnn_grid_sampler", self.tensor, grid.tensor).to(ATensor).newTensor()
proc cudnn_grid_sampler_backward*(ty: TensorType; self: Tensor, grid: Tensor, grad_output: Tensor): tuple[self: Tensor, grid: Tensor] {.inline, noinit.} = ty.dynamicCppCall("cudnn_grid_sampler_backward", self.tensor, grid.tensor, grad_output.tensor).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc cudnn_grid_sampler_backward*(self: Tensor, grid: Tensor, grad_output: Tensor): tuple[self: Tensor, grid: Tensor] {.inline, noinit.} = dynamicCCall("at::cudnn_grid_sampler_backward", self.tensor, grid.tensor, grad_output.tensor).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc cumsum*(ty: TensorType; self: Tensor, dim: int64, dtype: AScalarType): Tensor {.inline, noinit.} = ty.dynamicCppCall("cumsum", self.tensor, dim, dtype).to(ATensor).newTensor()
proc cumsum*(self: Tensor, dim: int64, dtype: AScalarType): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("cumsum", dim, dtype).to(ATensor).newTensor()
proc cumsum*(ty: TensorType; self: Tensor, dim: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("cumsum", self.tensor, dim).to(ATensor).newTensor()
proc cumsum*(self: Tensor, dim: int64): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("cumsum", dim).to(ATensor).newTensor()
proc cumprod*(ty: TensorType; self: Tensor, dim: int64, dtype: AScalarType): Tensor {.inline, noinit.} = ty.dynamicCppCall("cumprod", self.tensor, dim, dtype).to(ATensor).newTensor()
proc cumprod*(self: Tensor, dim: int64, dtype: AScalarType): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("cumprod", dim, dtype).to(ATensor).newTensor()
proc cumprod*(ty: TensorType; self: Tensor, dim: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("cumprod", self.tensor, dim).to(ATensor).newTensor()
proc cumprod*(self: Tensor, dim: int64): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("cumprod", dim).to(ATensor).newTensor()
proc ctc_loss*(ty: TensorType; log_probs: Tensor, targets: Tensor, input_lengths: IntList, target_lengths: IntList, blank: int64 = 0, reduction: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("ctc_loss", log_probs.tensor, targets.tensor, input_lengths, target_lengths, blank, reduction).to(ATensor).newTensor()
proc ctc_loss*(log_probs: Tensor, targets: Tensor, input_lengths: IntList, target_lengths: IntList, blank: int64 = 0, reduction: int64): Tensor {.inline, noinit.} = dynamicCCall("at::ctc_loss", log_probs.tensor, targets.tensor, input_lengths, target_lengths, blank, reduction).to(ATensor).newTensor()
proc ctc_loss*(ty: TensorType; log_probs: Tensor, targets: Tensor, input_lengths: Tensor, target_lengths: Tensor, blank: int64 = 0, reduction: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("ctc_loss", log_probs.tensor, targets.tensor, input_lengths.tensor, target_lengths.tensor, blank, reduction).to(ATensor).newTensor()
proc ctc_loss*(log_probs: Tensor, targets: Tensor, input_lengths: Tensor, target_lengths: Tensor, blank: int64 = 0, reduction: int64): Tensor {.inline, noinit.} = dynamicCCall("at::ctc_loss", log_probs.tensor, targets.tensor, input_lengths.tensor, target_lengths.tensor, blank, reduction).to(ATensor).newTensor()
proc u_ctc_loss*(ty: TensorType; log_probs: Tensor, targets: Tensor, input_lengths: IntList, target_lengths: IntList, blank: int64 = 0): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = ty.dynamicCppCall("_ctc_loss", log_probs.tensor, targets.tensor, input_lengths, target_lengths, blank).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc u_ctc_loss*(log_probs: Tensor, targets: Tensor, input_lengths: IntList, target_lengths: IntList, blank: int64 = 0): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = dynamicCCall("at::_ctc_loss", log_probs.tensor, targets.tensor, input_lengths, target_lengths, blank).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc u_ctc_loss_backward*(ty: TensorType; grad: Tensor, log_probs: Tensor, targets: Tensor, input_lengths: IntList, target_lengths: IntList, neg_log_likelihood: Tensor, log_alpha: Tensor, blank: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("_ctc_loss_backward", grad.tensor, log_probs.tensor, targets.tensor, input_lengths, target_lengths, neg_log_likelihood.tensor, log_alpha.tensor, blank).to(ATensor).newTensor()
proc u_ctc_loss_backward*(grad: Tensor, log_probs: Tensor, targets: Tensor, input_lengths: IntList, target_lengths: IntList, neg_log_likelihood: Tensor, log_alpha: Tensor, blank: int64): Tensor {.inline, noinit.} = dynamicCCall("at::_ctc_loss_backward", grad.tensor, log_probs.tensor, targets.tensor, input_lengths, target_lengths, neg_log_likelihood.tensor, log_alpha.tensor, blank).to(ATensor).newTensor()
proc det*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("det", self.tensor).to(ATensor).newTensor()
proc det*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("det").to(ATensor).newTensor()
proc diagflat*(ty: TensorType; self: Tensor, offset: int64 = 0): Tensor {.inline, noinit.} = ty.dynamicCppCall("diagflat", self.tensor, offset).to(ATensor).newTensor()
proc diagflat*(self: Tensor, offset: int64 = 0): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("diagflat", offset).to(ATensor).newTensor()
proc diagonal*(ty: TensorType; self: Tensor, offset: int64 = 0, dim1: int64 = 0, dim2: int64 = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("diagonal", self.tensor, offset, dim1, dim2).to(ATensor).newTensor()
proc diagonal*(self: Tensor, offset: int64 = 0, dim1: int64 = 0, dim2: int64 = 1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("diagonal", offset, dim1, dim2).to(ATensor).newTensor()
proc adiv*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("div", self.tensor, other.tensor).to(ATensor).newTensor()
proc adiv*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("div", other.tensor).to(ATensor).newTensor()
proc div_u*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("div_", self.tensor, other.tensor).to(ATensor).newTensor()
proc div_u*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("div_", other.tensor).to(ATensor).newTensor()
proc adiv*(ty: TensorType; self: Tensor, other: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("div", self.tensor, other).to(ATensor).newTensor()
proc adiv*(self: Tensor, other: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("div", other).to(ATensor).newTensor()
proc div_u*(ty: TensorType; self: Tensor, other: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("div_", self.tensor, other).to(ATensor).newTensor()
proc div_u*(self: Tensor, other: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("div_", other).to(ATensor).newTensor()
proc dot*(ty: TensorType; self: Tensor, tensor: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("dot", self.tensor, tensor.tensor).to(ATensor).newTensor()
proc dot*(self: Tensor, tensor: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("dot", tensor.tensor).to(ATensor).newTensor()
proc einsum*(ty: TensorType; equation: StdString, tensors: TensorList): Tensor {.inline, noinit.} = ty.dynamicCppCall("einsum", equation, tensors).to(ATensor).newTensor()
proc einsum*(equation: StdString, tensors: TensorList): Tensor {.inline, noinit.} = dynamicCCall("at::einsum", equation, tensors).to(ATensor).newTensor()
proc embedding*(ty: TensorType; weight: Tensor, indices: Tensor, padding_idx: int64 = -1, scale_grad_by_freq: bool = false, sparse: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("embedding", weight.tensor, indices.tensor, padding_idx, scale_grad_by_freq, sparse).to(ATensor).newTensor()
proc embedding*(weight: Tensor, indices: Tensor, padding_idx: int64 = -1, scale_grad_by_freq: bool = false, sparse: bool = false): Tensor {.inline, noinit.} = dynamicCCall("at::embedding", weight.tensor, indices.tensor, padding_idx, scale_grad_by_freq, sparse).to(ATensor).newTensor()
proc embedding_backward*(ty: TensorType; grad: Tensor, indices: Tensor, num_weights: int64, padding_idx: int64, scale_grad_by_freq: bool, sparse: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("embedding_backward", grad.tensor, indices.tensor, num_weights, padding_idx, scale_grad_by_freq, sparse).to(ATensor).newTensor()
proc embedding_backward*(grad: Tensor, indices: Tensor, num_weights: int64, padding_idx: int64, scale_grad_by_freq: bool, sparse: bool): Tensor {.inline, noinit.} = dynamicCCall("at::embedding_backward", grad.tensor, indices.tensor, num_weights, padding_idx, scale_grad_by_freq, sparse).to(ATensor).newTensor()
proc embedding_dense_backward*(ty: TensorType; grad: Tensor, indices: Tensor, num_weights: int64, padding_idx: int64, scale_grad_by_freq: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("embedding_dense_backward", grad.tensor, indices.tensor, num_weights, padding_idx, scale_grad_by_freq).to(ATensor).newTensor()
proc embedding_dense_backward*(grad: Tensor, indices: Tensor, num_weights: int64, padding_idx: int64, scale_grad_by_freq: bool): Tensor {.inline, noinit.} = dynamicCCall("at::embedding_dense_backward", grad.tensor, indices.tensor, num_weights, padding_idx, scale_grad_by_freq).to(ATensor).newTensor()
proc embedding_renorm_u*(ty: TensorType; self: Tensor, indices: Tensor, max_norm: float64, norm_type: float64): Tensor {.inline, noinit.} = ty.dynamicCppCall("embedding_renorm_", self.tensor, indices.tensor, max_norm, norm_type).to(ATensor).newTensor()
proc embedding_renorm_u*(self: Tensor, indices: Tensor, max_norm: float64, norm_type: float64): Tensor {.inline, noinit.} = dynamicCCall("at::embedding_renorm_", self.tensor, indices.tensor, max_norm, norm_type).to(ATensor).newTensor()
proc embedding_sparse_backward*(ty: TensorType; grad: Tensor, indices: Tensor, num_weights: int64, padding_idx: int64, scale_grad_by_freq: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("embedding_sparse_backward", grad.tensor, indices.tensor, num_weights, padding_idx, scale_grad_by_freq).to(ATensor).newTensor()
proc embedding_sparse_backward*(grad: Tensor, indices: Tensor, num_weights: int64, padding_idx: int64, scale_grad_by_freq: bool): Tensor {.inline, noinit.} = dynamicCCall("at::embedding_sparse_backward", grad.tensor, indices.tensor, num_weights, padding_idx, scale_grad_by_freq).to(ATensor).newTensor()
proc embedding_bag*(ty: TensorType; weight: Tensor, indices: Tensor, offsets: Tensor, scale_grad_by_freq: bool = false, mode: int64 = 0, sparse: bool = false): tuple[result0: Tensor, result1: Tensor, result2: Tensor, result3: Tensor] {.inline, noinit.} = ty.dynamicCppCall("embedding_bag", weight.tensor, indices.tensor, offsets.tensor, scale_grad_by_freq, mode, sparse).to(StdTuple4[ATensor, ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc embedding_bag*(weight: Tensor, indices: Tensor, offsets: Tensor, scale_grad_by_freq: bool = false, mode: int64 = 0, sparse: bool = false): tuple[result0: Tensor, result1: Tensor, result2: Tensor, result3: Tensor] {.inline, noinit.} = dynamicCCall("at::embedding_bag", weight.tensor, indices.tensor, offsets.tensor, scale_grad_by_freq, mode, sparse).to(StdTuple4[ATensor, ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc u_embedding_bag*(ty: TensorType; weight: Tensor, indices: Tensor, offsets: Tensor, scale_grad_by_freq: bool = false, mode: int64 = 0, sparse: bool = false): tuple[result0: Tensor, result1: Tensor, result2: Tensor, result3: Tensor] {.inline, noinit.} = ty.dynamicCppCall("_embedding_bag", weight.tensor, indices.tensor, offsets.tensor, scale_grad_by_freq, mode, sparse).to(StdTuple4[ATensor, ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc u_embedding_bag*(weight: Tensor, indices: Tensor, offsets: Tensor, scale_grad_by_freq: bool = false, mode: int64 = 0, sparse: bool = false): tuple[result0: Tensor, result1: Tensor, result2: Tensor, result3: Tensor] {.inline, noinit.} = dynamicCCall("at::_embedding_bag", weight.tensor, indices.tensor, offsets.tensor, scale_grad_by_freq, mode, sparse).to(StdTuple4[ATensor, ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc u_embedding_bag_backward*(ty: TensorType; grad: Tensor, indices: Tensor, offsets: Tensor, offset2bag: Tensor, bag_size: Tensor, maximum_indices: Tensor, num_weights: int64, scale_grad_by_freq: bool, mode: int64, sparse: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("_embedding_bag_backward", grad.tensor, indices.tensor, offsets.tensor, offset2bag.tensor, bag_size.tensor, maximum_indices.tensor, num_weights, scale_grad_by_freq, mode, sparse).to(ATensor).newTensor()
proc u_embedding_bag_backward*(grad: Tensor, indices: Tensor, offsets: Tensor, offset2bag: Tensor, bag_size: Tensor, maximum_indices: Tensor, num_weights: int64, scale_grad_by_freq: bool, mode: int64, sparse: bool): Tensor {.inline, noinit.} = dynamicCCall("at::_embedding_bag_backward", grad.tensor, indices.tensor, offsets.tensor, offset2bag.tensor, bag_size.tensor, maximum_indices.tensor, num_weights, scale_grad_by_freq, mode, sparse).to(ATensor).newTensor()
proc u_embedding_bag_sparse_backward*(ty: TensorType; grad: Tensor, indices: Tensor, offsets: Tensor, offset2bag: Tensor, bag_size: Tensor, num_weights: int64, scale_grad_by_freq: bool, mode: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("_embedding_bag_sparse_backward", grad.tensor, indices.tensor, offsets.tensor, offset2bag.tensor, bag_size.tensor, num_weights, scale_grad_by_freq, mode).to(ATensor).newTensor()
proc u_embedding_bag_sparse_backward*(grad: Tensor, indices: Tensor, offsets: Tensor, offset2bag: Tensor, bag_size: Tensor, num_weights: int64, scale_grad_by_freq: bool, mode: int64): Tensor {.inline, noinit.} = dynamicCCall("at::_embedding_bag_sparse_backward", grad.tensor, indices.tensor, offsets.tensor, offset2bag.tensor, bag_size.tensor, num_weights, scale_grad_by_freq, mode).to(ATensor).newTensor()
proc u_embedding_bag_dense_backward*(ty: TensorType; grad: Tensor, indices: Tensor, offsets: Tensor, offset2bag: Tensor, bag_size: Tensor, maximum_indices: Tensor, num_weights: int64, scale_grad_by_freq: bool, mode: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("_embedding_bag_dense_backward", grad.tensor, indices.tensor, offsets.tensor, offset2bag.tensor, bag_size.tensor, maximum_indices.tensor, num_weights, scale_grad_by_freq, mode).to(ATensor).newTensor()
proc u_embedding_bag_dense_backward*(grad: Tensor, indices: Tensor, offsets: Tensor, offset2bag: Tensor, bag_size: Tensor, maximum_indices: Tensor, num_weights: int64, scale_grad_by_freq: bool, mode: int64): Tensor {.inline, noinit.} = dynamicCCall("at::_embedding_bag_dense_backward", grad.tensor, indices.tensor, offsets.tensor, offset2bag.tensor, bag_size.tensor, maximum_indices.tensor, num_weights, scale_grad_by_freq, mode).to(ATensor).newTensor()
proc empty*(ty: TensorType; size: IntList, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("empty", size, options).to(ATensor).newTensor()
proc empty*(size: IntList, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::empty", size, options).to(ATensor).newTensor()
proc empty_like*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("empty_like", self.tensor).to(ATensor).newTensor()
proc empty_like*(self: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::empty_like", self.tensor).to(ATensor).newTensor()
proc empty_like*(ty: TensorType; self: Tensor, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("empty_like", self.tensor, options).to(ATensor).newTensor()
proc empty_like*(self: Tensor, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::empty_like", self.tensor, options).to(ATensor).newTensor()
proc erf*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("erf", self.tensor).to(ATensor).newTensor()
proc erf*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("erf").to(ATensor).newTensor()
proc erf_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("erf_", self.tensor).to(ATensor).newTensor()
proc erf_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("erf_").to(ATensor).newTensor()
proc erfc*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("erfc", self.tensor).to(ATensor).newTensor()
proc erfc*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("erfc").to(ATensor).newTensor()
proc erfc_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("erfc_", self.tensor).to(ATensor).newTensor()
proc erfc_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("erfc_").to(ATensor).newTensor()
proc exp*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("exp", self.tensor).to(ATensor).newTensor()
proc exp*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("exp").to(ATensor).newTensor()
proc exp_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("exp_", self.tensor).to(ATensor).newTensor()
proc exp_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("exp_").to(ATensor).newTensor()
proc expm1*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("expm1", self.tensor).to(ATensor).newTensor()
proc expm1*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("expm1").to(ATensor).newTensor()
proc expm1_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("expm1_", self.tensor).to(ATensor).newTensor()
proc expm1_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("expm1_").to(ATensor).newTensor()
proc expand*(ty: TensorType; self: Tensor, size: IntList, implicit: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("expand", self.tensor, size, implicit).to(ATensor).newTensor()
proc expand*(self: Tensor, size: IntList, implicit: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("expand", size, implicit).to(ATensor).newTensor()
proc expand_as*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("expand_as", self.tensor, other.tensor).to(ATensor).newTensor()
proc expand_as*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("expand_as", other.tensor).to(ATensor).newTensor()
proc eye*(ty: TensorType; n: int64, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("eye", n, options).to(ATensor).newTensor()
proc eye*(n: int64, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::eye", n, options).to(ATensor).newTensor()
proc eye*(ty: TensorType; n: int64, m: int64, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("eye", n, m, options).to(ATensor).newTensor()
proc eye*(n: int64, m: int64, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::eye", n, m, options).to(ATensor).newTensor()
proc flatten*(ty: TensorType; self: Tensor, start_dim: int64 = 0, end_dim: int64 = -1): Tensor {.inline, noinit.} = ty.dynamicCppCall("flatten", self.tensor, start_dim, end_dim).to(ATensor).newTensor()
proc flatten*(self: Tensor, start_dim: int64 = 0, end_dim: int64 = -1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("flatten", start_dim, end_dim).to(ATensor).newTensor()
proc fill_u*(ty: TensorType; self: Tensor, value: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("fill_", self.tensor, value).to(ATensor).newTensor()
proc fill_u*(self: Tensor, value: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("fill_", value).to(ATensor).newTensor()
proc fill_u*(ty: TensorType; self: Tensor, value: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("fill_", self.tensor, value.tensor).to(ATensor).newTensor()
proc fill_u*(self: Tensor, value: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("fill_", value.tensor).to(ATensor).newTensor()
proc floor*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("floor", self.tensor).to(ATensor).newTensor()
proc floor*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("floor").to(ATensor).newTensor()
proc floor_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("floor_", self.tensor).to(ATensor).newTensor()
proc floor_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("floor_").to(ATensor).newTensor()
proc full*(ty: TensorType; size: IntList, fill_value: float, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("full", size, fill_value, options).to(ATensor).newTensor()
proc full*(size: IntList, fill_value: float, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::full", size, fill_value, options).to(ATensor).newTensor()
proc full_like*(ty: TensorType; self: Tensor, fill_value: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("full_like", self.tensor, fill_value).to(ATensor).newTensor()
proc full_like*(self: Tensor, fill_value: float): Tensor {.inline, noinit.} = dynamicCCall("at::full_like", self.tensor, fill_value).to(ATensor).newTensor()
proc full_like*(ty: TensorType; self: Tensor, fill_value: float, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("full_like", self.tensor, fill_value, options).to(ATensor).newTensor()
proc full_like*(self: Tensor, fill_value: float, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::full_like", self.tensor, fill_value, options).to(ATensor).newTensor()
proc grid_sampler*(ty: TensorType; input: Tensor, grid: Tensor, interpolation_mode: int64, padding_mode: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("grid_sampler", input.tensor, grid.tensor, interpolation_mode, padding_mode).to(ATensor).newTensor()
proc grid_sampler*(input: Tensor, grid: Tensor, interpolation_mode: int64, padding_mode: int64): Tensor {.inline, noinit.} = dynamicCCall("at::grid_sampler", input.tensor, grid.tensor, interpolation_mode, padding_mode).to(ATensor).newTensor()
proc grid_sampler_2d*(ty: TensorType; input: Tensor, grid: Tensor, interpolation_mode: int64, padding_mode: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("grid_sampler_2d", input.tensor, grid.tensor, interpolation_mode, padding_mode).to(ATensor).newTensor()
proc grid_sampler_2d*(input: Tensor, grid: Tensor, interpolation_mode: int64, padding_mode: int64): Tensor {.inline, noinit.} = dynamicCCall("at::grid_sampler_2d", input.tensor, grid.tensor, interpolation_mode, padding_mode).to(ATensor).newTensor()
proc grid_sampler_2d_backward*(ty: TensorType; grad_output: Tensor, input: Tensor, grid: Tensor, interpolation_mode: int64, padding_mode: int64): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = ty.dynamicCppCall("grid_sampler_2d_backward", grad_output.tensor, input.tensor, grid.tensor, interpolation_mode, padding_mode).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc grid_sampler_2d_backward*(grad_output: Tensor, input: Tensor, grid: Tensor, interpolation_mode: int64, padding_mode: int64): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = dynamicCCall("at::grid_sampler_2d_backward", grad_output.tensor, input.tensor, grid.tensor, interpolation_mode, padding_mode).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc grid_sampler_3d*(ty: TensorType; input: Tensor, grid: Tensor, interpolation_mode: int64, padding_mode: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("grid_sampler_3d", input.tensor, grid.tensor, interpolation_mode, padding_mode).to(ATensor).newTensor()
proc grid_sampler_3d*(input: Tensor, grid: Tensor, interpolation_mode: int64, padding_mode: int64): Tensor {.inline, noinit.} = dynamicCCall("at::grid_sampler_3d", input.tensor, grid.tensor, interpolation_mode, padding_mode).to(ATensor).newTensor()
proc grid_sampler_3d_backward*(ty: TensorType; grad_output: Tensor, input: Tensor, grid: Tensor, interpolation_mode: int64, padding_mode: int64): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = ty.dynamicCppCall("grid_sampler_3d_backward", grad_output.tensor, input.tensor, grid.tensor, interpolation_mode, padding_mode).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc grid_sampler_3d_backward*(grad_output: Tensor, input: Tensor, grid: Tensor, interpolation_mode: int64, padding_mode: int64): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = dynamicCCall("at::grid_sampler_3d_backward", grad_output.tensor, input.tensor, grid.tensor, interpolation_mode, padding_mode).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc hann_window*(ty: TensorType; window_length: int64, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("hann_window", window_length, options).to(ATensor).newTensor()
proc hann_window*(window_length: int64, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::hann_window", window_length, options).to(ATensor).newTensor()
proc hann_window*(ty: TensorType; window_length: int64, periodic: bool, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("hann_window", window_length, periodic, options).to(ATensor).newTensor()
proc hann_window*(window_length: int64, periodic: bool, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::hann_window", window_length, periodic, options).to(ATensor).newTensor()
proc hamming_window*(ty: TensorType; window_length: int64, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("hamming_window", window_length, options).to(ATensor).newTensor()
proc hamming_window*(window_length: int64, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::hamming_window", window_length, options).to(ATensor).newTensor()
proc hamming_window*(ty: TensorType; window_length: int64, periodic: bool, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("hamming_window", window_length, periodic, options).to(ATensor).newTensor()
proc hamming_window*(window_length: int64, periodic: bool, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::hamming_window", window_length, periodic, options).to(ATensor).newTensor()
proc hamming_window*(ty: TensorType; window_length: int64, periodic: bool, alpha: float64, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("hamming_window", window_length, periodic, alpha, options).to(ATensor).newTensor()
proc hamming_window*(window_length: int64, periodic: bool, alpha: float64, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::hamming_window", window_length, periodic, alpha, options).to(ATensor).newTensor()
proc hamming_window*(ty: TensorType; window_length: int64, periodic: bool, alpha: float64, beta: float64, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("hamming_window", window_length, periodic, alpha, beta, options).to(ATensor).newTensor()
proc hamming_window*(window_length: int64, periodic: bool, alpha: float64, beta: float64, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::hamming_window", window_length, periodic, alpha, beta, options).to(ATensor).newTensor()
proc hinge_embedding_loss*(ty: TensorType; self: Tensor, target: Tensor, margin: float64, reduction: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("hinge_embedding_loss", self.tensor, target.tensor, margin, reduction).to(ATensor).newTensor()
proc hinge_embedding_loss*(self: Tensor, target: Tensor, margin: float64, reduction: int64): Tensor {.inline, noinit.} = dynamicCCall("at::hinge_embedding_loss", self.tensor, target.tensor, margin, reduction).to(ATensor).newTensor()
proc ger*(ty: TensorType; self: Tensor, vec2: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("ger", self.tensor, vec2.tensor).to(ATensor).newTensor()
proc ger*(self: Tensor, vec2: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("ger", vec2.tensor).to(ATensor).newTensor()
proc gesv*(ty: TensorType; self: Tensor, A: Tensor): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = ty.dynamicCppCall("gesv", self.tensor, A.tensor).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc gesv*(self: Tensor, A: Tensor): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = self.tensor.dynamicCppCall("gesv", A.tensor).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc u_gesv_helper*(ty: TensorType; self: Tensor, A: Tensor): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = ty.dynamicCppCall("_gesv_helper", self.tensor, A.tensor).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc u_gesv_helper*(self: Tensor, A: Tensor): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = self.tensor.dynamicCppCall("_gesv_helper", A.tensor).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc group_norm*(ty: TensorType; input: Tensor, num_groups: int64, weight: Tensor, bias: Tensor, eps: float64, cudnn_enabled: bool = true): Tensor {.inline, noinit.} = ty.dynamicCppCall("group_norm", input.tensor, num_groups, weight.tensor, bias.tensor, eps, cudnn_enabled).to(ATensor).newTensor()
proc group_norm*(input: Tensor, num_groups: int64, weight: Tensor, bias: Tensor, eps: float64, cudnn_enabled: bool = true): Tensor {.inline, noinit.} = dynamicCCall("at::group_norm", input.tensor, num_groups, weight.tensor, bias.tensor, eps, cudnn_enabled).to(ATensor).newTensor()
proc fft*(ty: TensorType; self: Tensor, signal_ndim: int64, normalized: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("fft", self.tensor, signal_ndim, normalized).to(ATensor).newTensor()
proc fft*(self: Tensor, signal_ndim: int64, normalized: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("fft", signal_ndim, normalized).to(ATensor).newTensor()
proc ifft*(ty: TensorType; self: Tensor, signal_ndim: int64, normalized: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("ifft", self.tensor, signal_ndim, normalized).to(ATensor).newTensor()
proc ifft*(self: Tensor, signal_ndim: int64, normalized: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("ifft", signal_ndim, normalized).to(ATensor).newTensor()
proc rfft*(ty: TensorType; self: Tensor, signal_ndim: int64, normalized: bool = false, onesided: bool = true): Tensor {.inline, noinit.} = ty.dynamicCppCall("rfft", self.tensor, signal_ndim, normalized, onesided).to(ATensor).newTensor()
proc rfft*(self: Tensor, signal_ndim: int64, normalized: bool = false, onesided: bool = true): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("rfft", signal_ndim, normalized, onesided).to(ATensor).newTensor()
proc irfft*(ty: TensorType; self: Tensor, signal_ndim: int64, normalized: bool = false, onesided: bool = true, signal_sizes: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("irfft", self.tensor, signal_ndim, normalized, onesided, signal_sizes).to(ATensor).newTensor()
proc irfft*(self: Tensor, signal_ndim: int64, normalized: bool = false, onesided: bool = true, signal_sizes: IntList): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("irfft", signal_ndim, normalized, onesided, signal_sizes).to(ATensor).newTensor()
proc u_fft_with_size*(ty: TensorType; self: Tensor, signal_ndim: int64, complex_input: bool, complex_output: bool, inverse: bool, checked_signal_sizes: IntList, normalized: bool, onesided: bool, output_sizes: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("_fft_with_size", self.tensor, signal_ndim, complex_input, complex_output, inverse, checked_signal_sizes, normalized, onesided, output_sizes).to(ATensor).newTensor()
proc u_fft_with_size*(self: Tensor, signal_ndim: int64, complex_input: bool, complex_output: bool, inverse: bool, checked_signal_sizes: IntList, normalized: bool, onesided: bool, output_sizes: IntList): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_fft_with_size", signal_ndim, complex_input, complex_output, inverse, checked_signal_sizes, normalized, onesided, output_sizes).to(ATensor).newTensor()
proc u_cufft_get_plan_cache_size*(ty: TensorType; ): int64 {.inline, noinit.} = ty.dynamicCppCall("_cufft_get_plan_cache_size").to(int64)
proc u_cufft_get_plan_cache_size*(): int64 {.inline, noinit.} = dynamicCCall("at::_cufft_get_plan_cache_size").to(int64)
proc u_cufft_get_plan_cache_max_size*(ty: TensorType; ): int64 {.inline, noinit.} = ty.dynamicCppCall("_cufft_get_plan_cache_max_size").to(int64)
proc u_cufft_get_plan_cache_max_size*(): int64 {.inline, noinit.} = dynamicCCall("at::_cufft_get_plan_cache_max_size").to(int64)
proc u_cufft_set_plan_cache_max_size*(ty: TensorType; max_size: int64): void {.inline, noinit.} = ty.dynamicCppCall("_cufft_set_plan_cache_max_size", max_size).to(void)
proc u_cufft_set_plan_cache_max_size*(max_size: int64): void {.inline, noinit.} = dynamicCCall("at::_cufft_set_plan_cache_max_size", max_size).to(void)
proc u_cufft_clear_plan_cache*(ty: TensorType; ): void {.inline, noinit.} = ty.dynamicCppCall("_cufft_clear_plan_cache").to(void)
proc u_cufft_clear_plan_cache*(): void {.inline, noinit.} = dynamicCCall("at::_cufft_clear_plan_cache").to(void)
proc index*(ty: TensorType; self: Tensor, indices: TensorList): Tensor {.inline, noinit.} = ty.dynamicCppCall("index", self.tensor, indices).to(ATensor).newTensor()
proc index*(self: Tensor, indices: TensorList): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("index", indices).to(ATensor).newTensor()
proc index_copy_u*(ty: TensorType; self: Tensor, dim: int64, index: Tensor, source: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("index_copy_", self.tensor, dim, index.tensor, source.tensor).to(ATensor).newTensor()
proc index_copy_u*(self: Tensor, dim: int64, index: Tensor, source: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("index_copy_", dim, index.tensor, source.tensor).to(ATensor).newTensor()
proc index_put*(ty: TensorType; self: Tensor, indices: TensorList, values: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("index_put", self.tensor, indices, values.tensor).to(ATensor).newTensor()
proc index_put*(self: Tensor, indices: TensorList, values: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("index_put", indices, values.tensor).to(ATensor).newTensor()
proc index_put_u*(ty: TensorType; self: Tensor, indices: TensorList, values: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("index_put_", self.tensor, indices, values.tensor).to(ATensor).newTensor()
proc index_put_u*(self: Tensor, indices: TensorList, values: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("index_put_", indices, values.tensor).to(ATensor).newTensor()
proc inverse*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("inverse", self.tensor).to(ATensor).newTensor()
proc inverse*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("inverse").to(ATensor).newTensor()
proc isclose*(ty: TensorType; self: Tensor, other: Tensor, rtol: float64, atol: float64, equal_nan: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("isclose", self.tensor, other.tensor, rtol, atol, equal_nan).to(ATensor).newTensor()
proc isclose*(self: Tensor, other: Tensor, rtol: float64, atol: float64, equal_nan: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("isclose", other.tensor, rtol, atol, equal_nan).to(ATensor).newTensor()
proc is_cuda*(ty: TensorType; self: Tensor): bool {.inline, noinit.} = ty.dynamicCppCall("is_cuda", self.tensor).to(bool)
proc is_cuda*(self: Tensor): bool {.inline, noinit.} = self.tensor.dynamicCppCall("is_cuda").to(bool)
proc is_distributed*(ty: TensorType; self: Tensor): bool {.inline, noinit.} = ty.dynamicCppCall("is_distributed", self.tensor).to(bool)
proc is_distributed*(self: Tensor): bool {.inline, noinit.} = self.tensor.dynamicCppCall("is_distributed").to(bool)
proc is_floating_point*(ty: TensorType; self: Tensor): bool {.inline, noinit.} = ty.dynamicCppCall("is_floating_point", self.tensor).to(bool)
proc is_floating_point*(self: Tensor): bool {.inline, noinit.} = self.tensor.dynamicCppCall("is_floating_point").to(bool)
proc is_nonzero*(ty: TensorType; self: Tensor): bool {.inline, noinit.} = ty.dynamicCppCall("is_nonzero", self.tensor).to(bool)
proc is_nonzero*(self: Tensor): bool {.inline, noinit.} = self.tensor.dynamicCppCall("is_nonzero").to(bool)
proc is_same_size*(ty: TensorType; self: Tensor, other: Tensor): bool {.inline, noinit.} = ty.dynamicCppCall("is_same_size", self.tensor, other.tensor).to(bool)
proc is_same_size*(self: Tensor, other: Tensor): bool {.inline, noinit.} = self.tensor.dynamicCppCall("is_same_size", other.tensor).to(bool)
proc is_signed*(ty: TensorType; self: Tensor): bool {.inline, noinit.} = ty.dynamicCppCall("is_signed", self.tensor).to(bool)
proc is_signed*(self: Tensor): bool {.inline, noinit.} = self.tensor.dynamicCppCall("is_signed").to(bool)
proc is_sparse*(ty: TensorType; self: Tensor): bool {.inline, noinit.} = ty.dynamicCppCall("is_sparse", self.tensor).to(bool)
proc is_sparse*(self: Tensor): bool {.inline, noinit.} = self.tensor.dynamicCppCall("is_sparse").to(bool)
proc kthvalue*(ty: TensorType; self: Tensor, k: int64, dim: int64 = -1, keepdim: bool = false): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = ty.dynamicCppCall("kthvalue", self.tensor, k, dim, keepdim).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc kthvalue*(self: Tensor, k: int64, dim: int64 = -1, keepdim: bool = false): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = self.tensor.dynamicCppCall("kthvalue", k, dim, keepdim).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc layer_norm*(ty: TensorType; input: Tensor, normalized_shape: IntList, weight: Tensor, bias: Tensor, eps: float64, cudnn_enable: bool = true): Tensor {.inline, noinit.} = ty.dynamicCppCall("layer_norm", input.tensor, normalized_shape, weight.tensor, bias.tensor, eps, cudnn_enable).to(ATensor).newTensor()
proc layer_norm*(input: Tensor, normalized_shape: IntList, weight: Tensor, bias: Tensor, eps: float64, cudnn_enable: bool = true): Tensor {.inline, noinit.} = dynamicCCall("at::layer_norm", input.tensor, normalized_shape, weight.tensor, bias.tensor, eps, cudnn_enable).to(ATensor).newTensor()
proc linspace*(ty: TensorType; start: float, aend: float, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("linspace", start, aend, options).to(ATensor).newTensor()
proc linspace*(start: float, aend: float, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::linspace", start, aend, options).to(ATensor).newTensor()
proc linspace*(ty: TensorType; start: float, aend: float, steps: int64, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("linspace", start, aend, steps, options).to(ATensor).newTensor()
proc linspace*(start: float, aend: float, steps: int64, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::linspace", start, aend, steps, options).to(ATensor).newTensor()
proc log*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("log", self.tensor).to(ATensor).newTensor()
proc log*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("log").to(ATensor).newTensor()
proc log_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("log_", self.tensor).to(ATensor).newTensor()
proc log_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("log_").to(ATensor).newTensor()
proc log10*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("log10", self.tensor).to(ATensor).newTensor()
proc log10*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("log10").to(ATensor).newTensor()
proc log10_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("log10_", self.tensor).to(ATensor).newTensor()
proc log10_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("log10_").to(ATensor).newTensor()
proc log1p*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("log1p", self.tensor).to(ATensor).newTensor()
proc log1p*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("log1p").to(ATensor).newTensor()
proc log1p_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("log1p_", self.tensor).to(ATensor).newTensor()
proc log1p_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("log1p_").to(ATensor).newTensor()
proc log2*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("log2", self.tensor).to(ATensor).newTensor()
proc log2*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("log2").to(ATensor).newTensor()
proc log2_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("log2_", self.tensor).to(ATensor).newTensor()
proc log2_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("log2_").to(ATensor).newTensor()
proc logdet*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("logdet", self.tensor).to(ATensor).newTensor()
proc logdet*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("logdet").to(ATensor).newTensor()
proc logspace*(ty: TensorType; start: float, aend: float, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("logspace", start, aend, options).to(ATensor).newTensor()
proc logspace*(start: float, aend: float, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::logspace", start, aend, options).to(ATensor).newTensor()
proc logspace*(ty: TensorType; start: float, aend: float, steps: int64, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("logspace", start, aend, steps, options).to(ATensor).newTensor()
proc logspace*(start: float, aend: float, steps: int64, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::logspace", start, aend, steps, options).to(ATensor).newTensor()
proc log_softmax*(ty: TensorType; self: Tensor, dim: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("log_softmax", self.tensor, dim).to(ATensor).newTensor()
proc log_softmax*(self: Tensor, dim: int64): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("log_softmax", dim).to(ATensor).newTensor()
proc log_softmax_backward_data*(ty: TensorType; grad_output: Tensor, output: Tensor, dim: int64, self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("log_softmax_backward_data", grad_output.tensor, output.tensor, dim, self.tensor).to(ATensor).newTensor()
proc log_softmax_backward_data*(grad_output: Tensor, output: Tensor, dim: int64, self: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::log_softmax_backward_data", grad_output.tensor, output.tensor, dim, self.tensor).to(ATensor).newTensor()
proc logsumexp*(ty: TensorType; self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("logsumexp", self.tensor, dim, keepdim).to(ATensor).newTensor()
proc logsumexp*(self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("logsumexp", dim, keepdim).to(ATensor).newTensor()
proc margin_ranking_loss*(ty: TensorType; input1: Tensor, input2: Tensor, target: Tensor, margin: float64, reduction: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("margin_ranking_loss", input1.tensor, input2.tensor, target.tensor, margin, reduction).to(ATensor).newTensor()
proc margin_ranking_loss*(input1: Tensor, input2: Tensor, target: Tensor, margin: float64, reduction: int64): Tensor {.inline, noinit.} = dynamicCCall("at::margin_ranking_loss", input1.tensor, input2.tensor, target.tensor, margin, reduction).to(ATensor).newTensor()
proc matmul*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("matmul", self.tensor, other.tensor).to(ATensor).newTensor()
proc matmul*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("matmul", other.tensor).to(ATensor).newTensor()
proc matrix_rank*(ty: TensorType; self: Tensor, tol: float64, symmetric: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("matrix_rank", self.tensor, tol, symmetric).to(ATensor).newTensor()
proc matrix_rank*(self: Tensor, tol: float64, symmetric: bool = false): Tensor {.inline, noinit.} = dynamicCCall("at::matrix_rank", self.tensor, tol, symmetric).to(ATensor).newTensor()
proc matrix_rank*(ty: TensorType; self: Tensor, symmetric: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("matrix_rank", self.tensor, symmetric).to(ATensor).newTensor()
proc matrix_rank*(self: Tensor, symmetric: bool = false): Tensor {.inline, noinit.} = dynamicCCall("at::matrix_rank", self.tensor, symmetric).to(ATensor).newTensor()
proc max*(ty: TensorType; self: Tensor, dim: int64, keepdim: bool = false): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = ty.dynamicCppCall("max", self.tensor, dim, keepdim).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc max*(self: Tensor, dim: int64, keepdim: bool = false): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = self.tensor.dynamicCppCall("max", dim, keepdim).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc max_values*(ty: TensorType; self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("max_values", self.tensor, dim, keepdim).to(ATensor).newTensor()
proc max_values*(self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("max_values", dim, keepdim).to(ATensor).newTensor()
proc max_pool1d_with_indices*(ty: TensorType; self: Tensor, kernel_size: IntList, stride: IntList, padding: IntList = @[0], dilation: IntList = @[1], ceil_mode: bool = false): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = ty.dynamicCppCall("max_pool1d_with_indices", self.tensor, kernel_size, stride, padding, dilation, ceil_mode).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc max_pool1d_with_indices*(self: Tensor, kernel_size: IntList, stride: IntList, padding: IntList = @[0], dilation: IntList = @[1], ceil_mode: bool = false): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = dynamicCCall("at::max_pool1d_with_indices", self.tensor, kernel_size, stride, padding, dilation, ceil_mode).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc max_pool1d*(ty: TensorType; self: Tensor, kernel_size: IntList, stride: IntList, padding: IntList = @[0], dilation: IntList = @[1], ceil_mode: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("max_pool1d", self.tensor, kernel_size, stride, padding, dilation, ceil_mode).to(ATensor).newTensor()
proc max_pool1d*(self: Tensor, kernel_size: IntList, stride: IntList, padding: IntList = @[0], dilation: IntList = @[1], ceil_mode: bool = false): Tensor {.inline, noinit.} = dynamicCCall("at::max_pool1d", self.tensor, kernel_size, stride, padding, dilation, ceil_mode).to(ATensor).newTensor()
proc max_pool2d*(ty: TensorType; self: Tensor, kernel_size: IntList, stride: IntList, padding: IntList = @[0], dilation: IntList = @[1], ceil_mode: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("max_pool2d", self.tensor, kernel_size, stride, padding, dilation, ceil_mode).to(ATensor).newTensor()
proc max_pool2d*(self: Tensor, kernel_size: IntList, stride: IntList, padding: IntList = @[0], dilation: IntList = @[1], ceil_mode: bool = false): Tensor {.inline, noinit.} = dynamicCCall("at::max_pool2d", self.tensor, kernel_size, stride, padding, dilation, ceil_mode).to(ATensor).newTensor()
proc max_pool3d*(ty: TensorType; self: Tensor, kernel_size: IntList, stride: IntList, padding: IntList = @[0], dilation: IntList = @[1], ceil_mode: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("max_pool3d", self.tensor, kernel_size, stride, padding, dilation, ceil_mode).to(ATensor).newTensor()
proc max_pool3d*(self: Tensor, kernel_size: IntList, stride: IntList, padding: IntList = @[0], dilation: IntList = @[1], ceil_mode: bool = false): Tensor {.inline, noinit.} = dynamicCCall("at::max_pool3d", self.tensor, kernel_size, stride, padding, dilation, ceil_mode).to(ATensor).newTensor()
proc mean*(ty: TensorType; self: Tensor, dtype: AScalarType): Tensor {.inline, noinit.} = ty.dynamicCppCall("mean", self.tensor, dtype).to(ATensor).newTensor()
proc mean*(self: Tensor, dtype: AScalarType): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("mean", dtype).to(ATensor).newTensor()
proc mean*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("mean", self.tensor).to(ATensor).newTensor()
proc mean*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("mean").to(ATensor).newTensor()
proc mean*(ty: TensorType; self: Tensor, dim: int64, keepdim: bool, dtype: AScalarType): Tensor {.inline, noinit.} = ty.dynamicCppCall("mean", self.tensor, dim, keepdim, dtype).to(ATensor).newTensor()
proc mean*(self: Tensor, dim: int64, keepdim: bool, dtype: AScalarType): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("mean", dim, keepdim, dtype).to(ATensor).newTensor()
proc mean*(ty: TensorType; self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("mean", self.tensor, dim, keepdim).to(ATensor).newTensor()
proc mean*(self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("mean", dim, keepdim).to(ATensor).newTensor()
proc mean*(ty: TensorType; self: Tensor, dim: int64, dtype: AScalarType): Tensor {.inline, noinit.} = ty.dynamicCppCall("mean", self.tensor, dim, dtype).to(ATensor).newTensor()
proc mean*(self: Tensor, dim: int64, dtype: AScalarType): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("mean", dim, dtype).to(ATensor).newTensor()
proc median*(ty: TensorType; self: Tensor, dim: int64, keepdim: bool = false): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = ty.dynamicCppCall("median", self.tensor, dim, keepdim).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc median*(self: Tensor, dim: int64, keepdim: bool = false): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = self.tensor.dynamicCppCall("median", dim, keepdim).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc min*(ty: TensorType; self: Tensor, dim: int64, keepdim: bool = false): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = ty.dynamicCppCall("min", self.tensor, dim, keepdim).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc min*(self: Tensor, dim: int64, keepdim: bool = false): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = self.tensor.dynamicCppCall("min", dim, keepdim).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc min_values*(ty: TensorType; self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("min_values", self.tensor, dim, keepdim).to(ATensor).newTensor()
proc min_values*(self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("min_values", dim, keepdim).to(ATensor).newTensor()
proc mkldnn_convolution*(ty: TensorType; self: Tensor, weight: Tensor, bias: Tensor, padding: IntList, stride: IntList, dilation: IntList, groups: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("mkldnn_convolution", self.tensor, weight.tensor, bias.tensor, padding, stride, dilation, groups).to(ATensor).newTensor()
proc mkldnn_convolution*(self: Tensor, weight: Tensor, bias: Tensor, padding: IntList, stride: IntList, dilation: IntList, groups: int64): Tensor {.inline, noinit.} = dynamicCCall("at::mkldnn_convolution", self.tensor, weight.tensor, bias.tensor, padding, stride, dilation, groups).to(ATensor).newTensor()
proc mkldnn_convolution_backward_input*(ty: TensorType; self_size: IntList, grad_output: Tensor, weight: Tensor, padding: IntList, stride: IntList, dilation: IntList, groups: int64, bias_defined: bool): Tensor {.inline, noinit.} = ty.dynamicCppCall("mkldnn_convolution_backward_input", self_size, grad_output.tensor, weight.tensor, padding, stride, dilation, groups, bias_defined).to(ATensor).newTensor()
proc mkldnn_convolution_backward_input*(self_size: IntList, grad_output: Tensor, weight: Tensor, padding: IntList, stride: IntList, dilation: IntList, groups: int64, bias_defined: bool): Tensor {.inline, noinit.} = dynamicCCall("at::mkldnn_convolution_backward_input", self_size, grad_output.tensor, weight.tensor, padding, stride, dilation, groups, bias_defined).to(ATensor).newTensor()
proc mkldnn_convolution_backward_weights*(ty: TensorType; weight_size: IntList, grad_output: Tensor, self: Tensor, padding: IntList, stride: IntList, dilation: IntList, groups: int64, bias_defined: bool): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = ty.dynamicCppCall("mkldnn_convolution_backward_weights", weight_size, grad_output.tensor, self.tensor, padding, stride, dilation, groups, bias_defined).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc mkldnn_convolution_backward_weights*(weight_size: IntList, grad_output: Tensor, self: Tensor, padding: IntList, stride: IntList, dilation: IntList, groups: int64, bias_defined: bool): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = dynamicCCall("at::mkldnn_convolution_backward_weights", weight_size, grad_output.tensor, self.tensor, padding, stride, dilation, groups, bias_defined).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc mkldnn_convolution_backward*(ty: TensorType; self: Tensor, grad_output: Tensor, weight: Tensor, padding: IntList, stride: IntList, dilation: IntList, groups: int64, output_mask: StdArray[bool, 3]): tuple[result0: Tensor, result1: Tensor, result2: Tensor] {.inline, noinit.} = ty.dynamicCppCall("mkldnn_convolution_backward", self.tensor, grad_output.tensor, weight.tensor, padding, stride, dilation, groups, output_mask).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc mkldnn_convolution_backward*(self: Tensor, grad_output: Tensor, weight: Tensor, padding: IntList, stride: IntList, dilation: IntList, groups: int64, output_mask: StdArray[bool, 3]): tuple[result0: Tensor, result1: Tensor, result2: Tensor] {.inline, noinit.} = dynamicCCall("at::mkldnn_convolution_backward", self.tensor, grad_output.tensor, weight.tensor, padding, stride, dilation, groups, output_mask).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc mm*(ty: TensorType; self: Tensor, mat2: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("mm", self.tensor, mat2.tensor).to(ATensor).newTensor()
proc mm*(self: Tensor, mat2: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("mm", mat2.tensor).to(ATensor).newTensor()
proc mode*(ty: TensorType; self: Tensor, dim: int64 = -1, keepdim: bool = false): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = ty.dynamicCppCall("mode", self.tensor, dim, keepdim).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc mode*(self: Tensor, dim: int64 = -1, keepdim: bool = false): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = self.tensor.dynamicCppCall("mode", dim, keepdim).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc mul*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("mul", self.tensor, other.tensor).to(ATensor).newTensor()
proc mul*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("mul", other.tensor).to(ATensor).newTensor()
proc mul_u*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("mul_", self.tensor, other.tensor).to(ATensor).newTensor()
proc mul_u*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("mul_", other.tensor).to(ATensor).newTensor()
proc mul*(ty: TensorType; self: Tensor, other: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("mul", self.tensor, other).to(ATensor).newTensor()
proc mul*(self: Tensor, other: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("mul", other).to(ATensor).newTensor()
proc mul_u*(ty: TensorType; self: Tensor, other: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("mul_", self.tensor, other).to(ATensor).newTensor()
proc mul_u*(self: Tensor, other: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("mul_", other).to(ATensor).newTensor()
proc mv*(ty: TensorType; self: Tensor, vec: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("mv", self.tensor, vec.tensor).to(ATensor).newTensor()
proc mv*(self: Tensor, vec: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("mv", vec.tensor).to(ATensor).newTensor()
proc mvlgamma*(ty: TensorType; self: Tensor, p: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("mvlgamma", self.tensor, p).to(ATensor).newTensor()
proc mvlgamma*(self: Tensor, p: int64): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("mvlgamma", p).to(ATensor).newTensor()
proc mvlgamma_u*(ty: TensorType; self: Tensor, p: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("mvlgamma_", self.tensor, p).to(ATensor).newTensor()
proc mvlgamma_u*(self: Tensor, p: int64): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("mvlgamma_", p).to(ATensor).newTensor()
proc narrow*(ty: TensorType; self: Tensor, dim: int64, start: int64, length: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("narrow", self.tensor, dim, start, length).to(ATensor).newTensor()
proc narrow*(self: Tensor, dim: int64, start: int64, length: int64): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("narrow", dim, start, length).to(ATensor).newTensor()
proc ones*(ty: TensorType; size: IntList, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("ones", size, options).to(ATensor).newTensor()
proc ones*(size: IntList, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::ones", size, options).to(ATensor).newTensor()
proc ones_like*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("ones_like", self.tensor).to(ATensor).newTensor()
proc ones_like*(self: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::ones_like", self.tensor).to(ATensor).newTensor()
proc ones_like*(ty: TensorType; self: Tensor, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("ones_like", self.tensor, options).to(ATensor).newTensor()
proc ones_like*(self: Tensor, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::ones_like", self.tensor, options).to(ATensor).newTensor()
proc pairwise_distance*(ty: TensorType; x1: Tensor, x2: Tensor, p: float64 = 2, eps: float64, keepdim: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("pairwise_distance", x1.tensor, x2.tensor, p, eps, keepdim).to(ATensor).newTensor()
proc pairwise_distance*(x1: Tensor, x2: Tensor, p: float64 = 2, eps: float64, keepdim: bool = false): Tensor {.inline, noinit.} = dynamicCCall("at::pairwise_distance", x1.tensor, x2.tensor, p, eps, keepdim).to(ATensor).newTensor()
proc permute*(ty: TensorType; self: Tensor, dims: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("permute", self.tensor, dims).to(ATensor).newTensor()
proc permute*(self: Tensor, dims: IntList): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("permute", dims).to(ATensor).newTensor()
proc pin_memory*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("pin_memory", self.tensor).to(ATensor).newTensor()
proc pin_memory*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("pin_memory").to(ATensor).newTensor()
proc pinverse*(ty: TensorType; self: Tensor, rcond: float64): Tensor {.inline, noinit.} = ty.dynamicCppCall("pinverse", self.tensor, rcond).to(ATensor).newTensor()
proc pinverse*(self: Tensor, rcond: float64): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("pinverse", rcond).to(ATensor).newTensor()
proc rand*(ty: TensorType; size: IntList, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("rand", size, options).to(ATensor).newTensor()
proc rand*(size: IntList, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::rand", size, options).to(ATensor).newTensor()
proc rand*(ty: TensorType; size: IntList, generator: pointer, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("rand", size, generator, options).to(ATensor).newTensor()
proc rand*(size: IntList, generator: pointer, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::rand", size, generator, options).to(ATensor).newTensor()
proc rand_like*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("rand_like", self.tensor).to(ATensor).newTensor()
proc rand_like*(self: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::rand_like", self.tensor).to(ATensor).newTensor()
proc rand_like*(ty: TensorType; self: Tensor, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("rand_like", self.tensor, options).to(ATensor).newTensor()
proc rand_like*(self: Tensor, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::rand_like", self.tensor, options).to(ATensor).newTensor()
proc randint*(ty: TensorType; high: int64, size: IntList, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("randint", high, size, options).to(ATensor).newTensor()
proc randint*(high: int64, size: IntList, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::randint", high, size, options).to(ATensor).newTensor()
proc randint*(ty: TensorType; high: int64, size: IntList, generator: pointer, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("randint", high, size, generator, options).to(ATensor).newTensor()
proc randint*(high: int64, size: IntList, generator: pointer, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::randint", high, size, generator, options).to(ATensor).newTensor()
proc randint*(ty: TensorType; low: int64, high: int64, size: IntList, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("randint", low, high, size, options).to(ATensor).newTensor()
proc randint*(low: int64, high: int64, size: IntList, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::randint", low, high, size, options).to(ATensor).newTensor()
proc randint*(ty: TensorType; low: int64, high: int64, size: IntList, generator: pointer, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("randint", low, high, size, generator, options).to(ATensor).newTensor()
proc randint*(low: int64, high: int64, size: IntList, generator: pointer, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::randint", low, high, size, generator, options).to(ATensor).newTensor()
proc randint_like*(ty: TensorType; self: Tensor, high: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("randint_like", self.tensor, high).to(ATensor).newTensor()
proc randint_like*(self: Tensor, high: int64): Tensor {.inline, noinit.} = dynamicCCall("at::randint_like", self.tensor, high).to(ATensor).newTensor()
proc randint_like*(ty: TensorType; self: Tensor, low: int64, high: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("randint_like", self.tensor, low, high).to(ATensor).newTensor()
proc randint_like*(self: Tensor, low: int64, high: int64): Tensor {.inline, noinit.} = dynamicCCall("at::randint_like", self.tensor, low, high).to(ATensor).newTensor()
proc randint_like*(ty: TensorType; self: Tensor, high: int64, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("randint_like", self.tensor, high, options).to(ATensor).newTensor()
proc randint_like*(self: Tensor, high: int64, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::randint_like", self.tensor, high, options).to(ATensor).newTensor()
proc randint_like*(ty: TensorType; self: Tensor, low: int64, high: int64, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("randint_like", self.tensor, low, high, options).to(ATensor).newTensor()
proc randint_like*(self: Tensor, low: int64, high: int64, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::randint_like", self.tensor, low, high, options).to(ATensor).newTensor()
proc randn*(ty: TensorType; size: IntList, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("randn", size, options).to(ATensor).newTensor()
proc randn*(size: IntList, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::randn", size, options).to(ATensor).newTensor()
proc randn*(ty: TensorType; size: IntList, generator: pointer, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("randn", size, generator, options).to(ATensor).newTensor()
proc randn*(size: IntList, generator: pointer, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::randn", size, generator, options).to(ATensor).newTensor()
proc randn_like*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("randn_like", self.tensor).to(ATensor).newTensor()
proc randn_like*(self: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::randn_like", self.tensor).to(ATensor).newTensor()
proc randn_like*(ty: TensorType; self: Tensor, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("randn_like", self.tensor, options).to(ATensor).newTensor()
proc randn_like*(self: Tensor, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::randn_like", self.tensor, options).to(ATensor).newTensor()
proc randperm*(ty: TensorType; n: int64, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("randperm", n, options).to(ATensor).newTensor()
proc randperm*(n: int64, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::randperm", n, options).to(ATensor).newTensor()
proc randperm*(ty: TensorType; n: int64, generator: pointer, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("randperm", n, generator, options).to(ATensor).newTensor()
proc randperm*(n: int64, generator: pointer, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::randperm", n, generator, options).to(ATensor).newTensor()
proc range*(ty: TensorType; start: float, aend: float, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("range", start, aend, options).to(ATensor).newTensor()
proc range*(start: float, aend: float, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::range", start, aend, options).to(ATensor).newTensor()
proc range*(ty: TensorType; start: float, aend: float, step: float, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("range", start, aend, step, options).to(ATensor).newTensor()
proc range*(start: float, aend: float, step: float, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::range", start, aend, step, options).to(ATensor).newTensor()
proc repeat*(ty: TensorType; self: Tensor, repeats: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("repeat", self.tensor, repeats).to(ATensor).newTensor()
proc repeat*(self: Tensor, repeats: IntList): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("repeat", repeats).to(ATensor).newTensor()
proc reshape*(ty: TensorType; self: Tensor, shape: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("reshape", self.tensor, shape).to(ATensor).newTensor()
proc reshape*(self: Tensor, shape: IntList): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("reshape", shape).to(ATensor).newTensor()
proc reshape_as*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("reshape_as", self.tensor, other.tensor).to(ATensor).newTensor()
proc reshape_as*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("reshape_as", other.tensor).to(ATensor).newTensor()
proc RoiPooling2d_forward*(ty: TensorType; input: Tensor, rois: Tensor, pooledHeight: int64, pooledWidth: int64, spatialScale: float64): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = ty.dynamicCppCall("RoiPooling2d_forward", input.tensor, rois.tensor, pooledHeight, pooledWidth, spatialScale).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc RoiPooling2d_forward*(input: Tensor, rois: Tensor, pooledHeight: int64, pooledWidth: int64, spatialScale: float64): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = dynamicCCall("at::RoiPooling2d_forward", input.tensor, rois.tensor, pooledHeight, pooledWidth, spatialScale).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc RoiPooling2d_backward*(ty: TensorType; input: Tensor, rois: Tensor, pooledHeight: int64, pooledWidth: int64, spatialScale: float64, gradOutput: Tensor, argmaxes: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("RoiPooling2d_backward", input.tensor, rois.tensor, pooledHeight, pooledWidth, spatialScale, gradOutput.tensor, argmaxes.tensor).to(ATensor).newTensor()
proc RoiPooling2d_backward*(input: Tensor, rois: Tensor, pooledHeight: int64, pooledWidth: int64, spatialScale: float64, gradOutput: Tensor, argmaxes: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::RoiPooling2d_backward", input.tensor, rois.tensor, pooledHeight, pooledWidth, spatialScale, gradOutput.tensor, argmaxes.tensor).to(ATensor).newTensor()
proc round*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("round", self.tensor).to(ATensor).newTensor()
proc round*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("round").to(ATensor).newTensor()
proc round_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("round_", self.tensor).to(ATensor).newTensor()
proc round_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("round_").to(ATensor).newTensor()
proc rrelu*(ty: TensorType; self: Tensor, lower: float, upper: float, training: bool = false, generator: pointer = nil): Tensor {.inline, noinit.} = ty.dynamicCppCall("rrelu", self.tensor, lower, upper, training, generator).to(ATensor).newTensor()
proc rrelu*(self: Tensor, lower: float, upper: float, training: bool = false, generator: pointer = nil): Tensor {.inline, noinit.} = dynamicCCall("at::rrelu", self.tensor, lower, upper, training, generator).to(ATensor).newTensor()
proc rrelu_u*(ty: TensorType; self: Tensor, lower: float, upper: float, training: bool = false, generator: pointer = nil): Tensor {.inline, noinit.} = ty.dynamicCppCall("rrelu_", self.tensor, lower, upper, training, generator).to(ATensor).newTensor()
proc rrelu_u*(self: Tensor, lower: float, upper: float, training: bool = false, generator: pointer = nil): Tensor {.inline, noinit.} = dynamicCCall("at::rrelu_", self.tensor, lower, upper, training, generator).to(ATensor).newTensor()
proc relu*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("relu", self.tensor).to(ATensor).newTensor()
proc relu*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("relu").to(ATensor).newTensor()
proc relu_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("relu_", self.tensor).to(ATensor).newTensor()
proc relu_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("relu_").to(ATensor).newTensor()
proc hardshrink*(ty: TensorType; self: Tensor, lambd: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("hardshrink", self.tensor, lambd).to(ATensor).newTensor()
proc hardshrink*(self: Tensor, lambd: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("hardshrink", lambd).to(ATensor).newTensor()
proc hardshrink_backward*(ty: TensorType; grad_out: Tensor, self: Tensor, lambd: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("hardshrink_backward", grad_out.tensor, self.tensor, lambd).to(ATensor).newTensor()
proc hardshrink_backward*(grad_out: Tensor, self: Tensor, lambd: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("hardshrink_backward", grad_out.tensor, lambd).to(ATensor).newTensor()
proc rsqrt*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("rsqrt", self.tensor).to(ATensor).newTensor()
proc rsqrt*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("rsqrt").to(ATensor).newTensor()
proc rsqrt_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("rsqrt_", self.tensor).to(ATensor).newTensor()
proc rsqrt_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("rsqrt_").to(ATensor).newTensor()
proc select*(ty: TensorType; self: Tensor, dim: int64, index: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("select", self.tensor, dim, index).to(ATensor).newTensor()
proc select*(self: Tensor, dim: int64, index: int64): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("select", dim, index).to(ATensor).newTensor()
proc selu*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("selu", self.tensor).to(ATensor).newTensor()
proc selu*(self: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::selu", self.tensor).to(ATensor).newTensor()
proc selu_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("selu_", self.tensor).to(ATensor).newTensor()
proc selu_u*(self: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::selu_", self.tensor).to(ATensor).newTensor()
proc celu*(ty: TensorType; self: Tensor, alpha: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("celu", self.tensor, alpha).to(ATensor).newTensor()
proc celu*(self: Tensor, alpha: float): Tensor {.inline, noinit.} = dynamicCCall("at::celu", self.tensor, alpha).to(ATensor).newTensor()
proc celu_u*(ty: TensorType; self: Tensor, alpha: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("celu_", self.tensor, alpha).to(ATensor).newTensor()
proc celu_u*(self: Tensor, alpha: float): Tensor {.inline, noinit.} = dynamicCCall("at::celu_", self.tensor, alpha).to(ATensor).newTensor()
proc sigmoid*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("sigmoid", self.tensor).to(ATensor).newTensor()
proc sigmoid*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("sigmoid").to(ATensor).newTensor()
proc sigmoid_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("sigmoid_", self.tensor).to(ATensor).newTensor()
proc sigmoid_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("sigmoid_").to(ATensor).newTensor()
proc sin*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("sin", self.tensor).to(ATensor).newTensor()
proc sin*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("sin").to(ATensor).newTensor()
proc sin_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("sin_", self.tensor).to(ATensor).newTensor()
proc sin_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("sin_").to(ATensor).newTensor()
proc sinh*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("sinh", self.tensor).to(ATensor).newTensor()
proc sinh*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("sinh").to(ATensor).newTensor()
proc sinh_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("sinh_", self.tensor).to(ATensor).newTensor()
proc sinh_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("sinh_").to(ATensor).newTensor()
proc size*(ty: TensorType; self: Tensor, dim: int64): int64 {.inline, noinit.} = ty.dynamicCppCall("size", self.tensor, dim).to(int64)
proc size*(self: Tensor, dim: int64): int64 {.inline, noinit.} = self.tensor.dynamicCppCall("size", dim).to(int64)
proc slice*(ty: TensorType; self: Tensor, dim: int64 = 0, start: int64 = 0, aend: int64 = 9223372036854775807, step: int64 = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("slice", self.tensor, dim, start, aend, step).to(ATensor).newTensor()
proc slice*(self: Tensor, dim: int64 = 0, start: int64 = 0, aend: int64 = 9223372036854775807, step: int64 = 1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("slice", dim, start, aend, step).to(ATensor).newTensor()
proc slogdet*(ty: TensorType; self: Tensor): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = ty.dynamicCppCall("slogdet", self.tensor).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc slogdet*(self: Tensor): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = self.tensor.dynamicCppCall("slogdet").to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc smm*(ty: TensorType; self: Tensor, mat2: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("smm", self.tensor, mat2.tensor).to(ATensor).newTensor()
proc smm*(self: Tensor, mat2: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("smm", mat2.tensor).to(ATensor).newTensor()
proc softmax*(ty: TensorType; self: Tensor, dim: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("softmax", self.tensor, dim).to(ATensor).newTensor()
proc softmax*(self: Tensor, dim: int64): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("softmax", dim).to(ATensor).newTensor()
proc softmax_backward_data*(ty: TensorType; grad_output: Tensor, output: Tensor, dim: int64, self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("softmax_backward_data", grad_output.tensor, output.tensor, dim, self.tensor).to(ATensor).newTensor()
proc softmax_backward_data*(grad_output: Tensor, output: Tensor, dim: int64, self: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::softmax_backward_data", grad_output.tensor, output.tensor, dim, self.tensor).to(ATensor).newTensor()
proc split*(ty: TensorType; self: Tensor, split_size: int64, dim: int64 = 0): TensorList {.inline, noinit.} = ty.dynamicCppCall("split", self.tensor, split_size, dim).to(TensorList)
proc split*(self: Tensor, split_size: int64, dim: int64 = 0): TensorList {.inline, noinit.} = self.tensor.dynamicCppCall("split", split_size, dim).to(TensorList)
proc split_with_sizes*(ty: TensorType; self: Tensor, split_sizes: IntList, dim: int64 = 0): TensorList {.inline, noinit.} = ty.dynamicCppCall("split_with_sizes", self.tensor, split_sizes, dim).to(TensorList)
proc split_with_sizes*(self: Tensor, split_sizes: IntList, dim: int64 = 0): TensorList {.inline, noinit.} = self.tensor.dynamicCppCall("split_with_sizes", split_sizes, dim).to(TensorList)
proc squeeze*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("squeeze", self.tensor).to(ATensor).newTensor()
proc squeeze*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("squeeze").to(ATensor).newTensor()
proc squeeze*(ty: TensorType; self: Tensor, dim: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("squeeze", self.tensor, dim).to(ATensor).newTensor()
proc squeeze*(self: Tensor, dim: int64): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("squeeze", dim).to(ATensor).newTensor()
proc squeeze_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("squeeze_", self.tensor).to(ATensor).newTensor()
proc squeeze_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("squeeze_").to(ATensor).newTensor()
proc squeeze_u*(ty: TensorType; self: Tensor, dim: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("squeeze_", self.tensor, dim).to(ATensor).newTensor()
proc squeeze_u*(self: Tensor, dim: int64): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("squeeze_", dim).to(ATensor).newTensor()
proc sspaddmm*(ty: TensorType; self: Tensor, mat1: Tensor, mat2: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("sspaddmm", self.tensor, mat1.tensor, mat2.tensor, beta, alpha).to(ATensor).newTensor()
proc sspaddmm*(self: Tensor, mat1: Tensor, mat2: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("sspaddmm", mat1.tensor, mat2.tensor, beta, alpha).to(ATensor).newTensor()
proc stack*(ty: TensorType; tensors: TensorList, dim: int64 = 0): Tensor {.inline, noinit.} = ty.dynamicCppCall("stack", tensors, dim).to(ATensor).newTensor()
proc stack*(tensors: TensorList, dim: int64 = 0): Tensor {.inline, noinit.} = dynamicCCall("at::stack", tensors, dim).to(ATensor).newTensor()
proc stft*(ty: TensorType; self: Tensor, n_fft: int64, hop_length: int64, win_length: int64, window: Tensor, normalized: bool = false, onesided: bool = true): Tensor {.inline, noinit.} = ty.dynamicCppCall("stft", self.tensor, n_fft, hop_length, win_length, window.tensor, normalized, onesided).to(ATensor).newTensor()
proc stft*(self: Tensor, n_fft: int64, hop_length: int64, win_length: int64, window: Tensor, normalized: bool = false, onesided: bool = true): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("stft", n_fft, hop_length, win_length, window.tensor, normalized, onesided).to(ATensor).newTensor()
proc stride*(ty: TensorType; self: Tensor, dim: int64): int64 {.inline, noinit.} = ty.dynamicCppCall("stride", self.tensor, dim).to(int64)
proc stride*(self: Tensor, dim: int64): int64 {.inline, noinit.} = self.tensor.dynamicCppCall("stride", dim).to(int64)
proc sum*(ty: TensorType; self: Tensor, dtype: AScalarType): Tensor {.inline, noinit.} = ty.dynamicCppCall("sum", self.tensor, dtype).to(ATensor).newTensor()
proc sum*(self: Tensor, dtype: AScalarType): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("sum", dtype).to(ATensor).newTensor()
proc sum*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("sum", self.tensor).to(ATensor).newTensor()
proc sum*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("sum").to(ATensor).newTensor()
proc u_sum*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_sum", self.tensor).to(ATensor).newTensor()
proc u_sum*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_sum").to(ATensor).newTensor()
proc sum*(ty: TensorType; self: Tensor, dim: IntList, keepdim: bool, dtype: AScalarType): Tensor {.inline, noinit.} = ty.dynamicCppCall("sum", self.tensor, dim, keepdim, dtype).to(ATensor).newTensor()
proc sum*(self: Tensor, dim: IntList, keepdim: bool, dtype: AScalarType): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("sum", dim, keepdim, dtype).to(ATensor).newTensor()
proc sum*(ty: TensorType; self: Tensor, dim: IntList, keepdim: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("sum", self.tensor, dim, keepdim).to(ATensor).newTensor()
proc sum*(self: Tensor, dim: IntList, keepdim: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("sum", dim, keepdim).to(ATensor).newTensor()
proc sum*(ty: TensorType; self: Tensor, dim: IntList, dtype: AScalarType): Tensor {.inline, noinit.} = ty.dynamicCppCall("sum", self.tensor, dim, dtype).to(ATensor).newTensor()
proc sum*(self: Tensor, dim: IntList, dtype: AScalarType): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("sum", dim, dtype).to(ATensor).newTensor()
proc u_sum*(ty: TensorType; self: Tensor, dim: IntList, keepdim: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("_sum", self.tensor, dim, keepdim).to(ATensor).newTensor()
proc u_sum*(self: Tensor, dim: IntList, keepdim: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_sum", dim, keepdim).to(ATensor).newTensor()
proc sqrt*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("sqrt", self.tensor).to(ATensor).newTensor()
proc sqrt*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("sqrt").to(ATensor).newTensor()
proc sqrt_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("sqrt_", self.tensor).to(ATensor).newTensor()
proc sqrt_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("sqrt_").to(ATensor).newTensor()
proc std*(ty: TensorType; self: Tensor, unbiased: bool = true): Tensor {.inline, noinit.} = ty.dynamicCppCall("std", self.tensor, unbiased).to(ATensor).newTensor()
proc std*(self: Tensor, unbiased: bool = true): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("std", unbiased).to(ATensor).newTensor()
proc std*(ty: TensorType; self: Tensor, dim: int64, unbiased: bool = true, keepdim: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("std", self.tensor, dim, unbiased, keepdim).to(ATensor).newTensor()
proc std*(self: Tensor, dim: int64, unbiased: bool = true, keepdim: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("std", dim, unbiased, keepdim).to(ATensor).newTensor()
proc prod*(ty: TensorType; self: Tensor, dtype: AScalarType): Tensor {.inline, noinit.} = ty.dynamicCppCall("prod", self.tensor, dtype).to(ATensor).newTensor()
proc prod*(self: Tensor, dtype: AScalarType): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("prod", dtype).to(ATensor).newTensor()
proc prod*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("prod", self.tensor).to(ATensor).newTensor()
proc prod*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("prod").to(ATensor).newTensor()
proc u_prod*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_prod", self.tensor).to(ATensor).newTensor()
proc u_prod*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_prod").to(ATensor).newTensor()
proc prod*(ty: TensorType; self: Tensor, dim: int64, keepdim: bool, dtype: AScalarType): Tensor {.inline, noinit.} = ty.dynamicCppCall("prod", self.tensor, dim, keepdim, dtype).to(ATensor).newTensor()
proc prod*(self: Tensor, dim: int64, keepdim: bool, dtype: AScalarType): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("prod", dim, keepdim, dtype).to(ATensor).newTensor()
proc prod*(ty: TensorType; self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("prod", self.tensor, dim, keepdim).to(ATensor).newTensor()
proc prod*(self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("prod", dim, keepdim).to(ATensor).newTensor()
proc prod*(ty: TensorType; self: Tensor, dim: int64, dtype: AScalarType): Tensor {.inline, noinit.} = ty.dynamicCppCall("prod", self.tensor, dim, dtype).to(ATensor).newTensor()
proc prod*(self: Tensor, dim: int64, dtype: AScalarType): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("prod", dim, dtype).to(ATensor).newTensor()
proc u_prod*(ty: TensorType; self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("_prod", self.tensor, dim, keepdim).to(ATensor).newTensor()
proc u_prod*(self: Tensor, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_prod", dim, keepdim).to(ATensor).newTensor()
proc t*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("t", self.tensor).to(ATensor).newTensor()
proc t*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("t").to(ATensor).newTensor()
proc t_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("t_", self.tensor).to(ATensor).newTensor()
proc t_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("t_").to(ATensor).newTensor()
proc tan*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("tan", self.tensor).to(ATensor).newTensor()
proc tan*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("tan").to(ATensor).newTensor()
proc tan_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("tan_", self.tensor).to(ATensor).newTensor()
proc tan_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("tan_").to(ATensor).newTensor()
proc tanh*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("tanh", self.tensor).to(ATensor).newTensor()
proc tanh*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("tanh").to(ATensor).newTensor()
proc tanh_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("tanh_", self.tensor).to(ATensor).newTensor()
proc tanh_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("tanh_").to(ATensor).newTensor()
proc transpose*(ty: TensorType; self: Tensor, dim0: int64, dim1: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("transpose", self.tensor, dim0, dim1).to(ATensor).newTensor()
proc transpose*(self: Tensor, dim0: int64, dim1: int64): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("transpose", dim0, dim1).to(ATensor).newTensor()
proc transpose_u*(ty: TensorType; self: Tensor, dim0: int64, dim1: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("transpose_", self.tensor, dim0, dim1).to(ATensor).newTensor()
proc transpose_u*(self: Tensor, dim0: int64, dim1: int64): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("transpose_", dim0, dim1).to(ATensor).newTensor()
proc flip*(ty: TensorType; self: Tensor, dims: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("flip", self.tensor, dims).to(ATensor).newTensor()
proc flip*(self: Tensor, dims: IntList): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("flip", dims).to(ATensor).newTensor()
proc rot90*(ty: TensorType; self: Tensor, k: int64 = 1, dims: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("rot90", self.tensor, k, dims).to(ATensor).newTensor()
proc rot90*(self: Tensor, k: int64 = 1, dims: IntList): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("rot90", k, dims).to(ATensor).newTensor()
proc u_trilinear*(ty: TensorType; i1: Tensor, i2: Tensor, i3: Tensor, expand1: IntList, expand2: IntList, expand3: IntList, sumdim: IntList, unroll_dim: int64 = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("_trilinear", i1.tensor, i2.tensor, i3.tensor, expand1, expand2, expand3, sumdim, unroll_dim).to(ATensor).newTensor()
proc u_trilinear*(i1: Tensor, i2: Tensor, i3: Tensor, expand1: IntList, expand2: IntList, expand3: IntList, sumdim: IntList, unroll_dim: int64 = 1): Tensor {.inline, noinit.} = dynamicCCall("at::_trilinear", i1.tensor, i2.tensor, i3.tensor, expand1, expand2, expand3, sumdim, unroll_dim).to(ATensor).newTensor()
proc triplet_margin_loss*(ty: TensorType; anchor: Tensor, positive: Tensor, negative: Tensor, margin: float64, p: float64 = 2, eps: float64, swap: bool = false, reduction: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("triplet_margin_loss", anchor.tensor, positive.tensor, negative.tensor, margin, p, eps, swap, reduction).to(ATensor).newTensor()
proc triplet_margin_loss*(anchor: Tensor, positive: Tensor, negative: Tensor, margin: float64, p: float64 = 2, eps: float64, swap: bool = false, reduction: int64): Tensor {.inline, noinit.} = dynamicCCall("at::triplet_margin_loss", anchor.tensor, positive.tensor, negative.tensor, margin, p, eps, swap, reduction).to(ATensor).newTensor()
proc trunc*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("trunc", self.tensor).to(ATensor).newTensor()
proc trunc*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("trunc").to(ATensor).newTensor()
proc trunc_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("trunc_", self.tensor).to(ATensor).newTensor()
proc trunc_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("trunc_").to(ATensor).newTensor()
proc type_as*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("type_as", self.tensor, other.tensor).to(ATensor).newTensor()
proc type_as*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("type_as", other.tensor).to(ATensor).newTensor()
proc u_unique*(ty: TensorType; self: Tensor, sorted: bool = false, return_inverse: bool = false): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = ty.dynamicCppCall("_unique", self.tensor, sorted, return_inverse).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc u_unique*(self: Tensor, sorted: bool = false, return_inverse: bool = false): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = self.tensor.dynamicCppCall("_unique", sorted, return_inverse).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc u_unsafe_view*(ty: TensorType; self: Tensor, size: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("_unsafe_view", self.tensor, size).to(ATensor).newTensor()
proc u_unsafe_view*(self: Tensor, size: IntList): Tensor {.inline, noinit.} = dynamicCCall("at::_unsafe_view", self.tensor, size).to(ATensor).newTensor()
proc unsqueeze*(ty: TensorType; self: Tensor, dim: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("unsqueeze", self.tensor, dim).to(ATensor).newTensor()
proc unsqueeze*(self: Tensor, dim: int64): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("unsqueeze", dim).to(ATensor).newTensor()
proc unsqueeze_u*(ty: TensorType; self: Tensor, dim: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("unsqueeze_", self.tensor, dim).to(ATensor).newTensor()
proc unsqueeze_u*(self: Tensor, dim: int64): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("unsqueeze_", dim).to(ATensor).newTensor()
proc avar*(ty: TensorType; self: Tensor, unbiased: bool = true): Tensor {.inline, noinit.} = ty.dynamicCppCall("var", self.tensor, unbiased).to(ATensor).newTensor()
proc avar*(self: Tensor, unbiased: bool = true): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("var", unbiased).to(ATensor).newTensor()
proc avar*(ty: TensorType; self: Tensor, dim: int64, unbiased: bool = true, keepdim: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("var", self.tensor, dim, unbiased, keepdim).to(ATensor).newTensor()
proc avar*(self: Tensor, dim: int64, unbiased: bool = true, keepdim: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("var", dim, unbiased, keepdim).to(ATensor).newTensor()
proc view_as*(ty: TensorType; self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("view_as", self.tensor, other.tensor).to(ATensor).newTensor()
proc view_as*(self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("view_as", other.tensor).to(ATensor).newTensor()
proc where*(ty: TensorType; condition: Tensor, self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("where", condition.tensor, self.tensor, other.tensor).to(ATensor).newTensor()
proc where*(condition: Tensor, self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("where", condition.tensor, other.tensor).to(ATensor).newTensor()
proc u_s_where*(ty: TensorType; condition: Tensor, self: Tensor, other: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_s_where", condition.tensor, self.tensor, other.tensor).to(ATensor).newTensor()
proc u_s_where*(condition: Tensor, self: Tensor, other: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_s_where", condition.tensor, other.tensor).to(ATensor).newTensor()
proc zeros*(ty: TensorType; size: IntList, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("zeros", size, options).to(ATensor).newTensor()
proc zeros*(size: IntList, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::zeros", size, options).to(ATensor).newTensor()
proc zeros_like*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("zeros_like", self.tensor).to(ATensor).newTensor()
proc zeros_like*(self: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::zeros_like", self.tensor).to(ATensor).newTensor()
proc zeros_like*(ty: TensorType; self: Tensor, options: TensorOptions): Tensor {.inline, noinit.} = ty.dynamicCppCall("zeros_like", self.tensor, options).to(ATensor).newTensor()
proc zeros_like*(self: Tensor, options: TensorOptions): Tensor {.inline, noinit.} = dynamicCCall("at::zeros_like", self.tensor, options).to(ATensor).newTensor()
proc u_standard_gamma_grad*(ty: TensorType; self: Tensor, output: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_standard_gamma_grad", self.tensor, output.tensor).to(ATensor).newTensor()
proc u_standard_gamma_grad*(self: Tensor, output: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_standard_gamma_grad", output.tensor).to(ATensor).newTensor()
proc u_standard_gamma*(ty: TensorType; self: Tensor, generator: pointer = nil): Tensor {.inline, noinit.} = ty.dynamicCppCall("_standard_gamma", self.tensor, generator).to(ATensor).newTensor()
proc u_standard_gamma*(self: Tensor, generator: pointer = nil): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_standard_gamma", generator).to(ATensor).newTensor()
proc poisson*(ty: TensorType; self: Tensor, generator: pointer = nil): Tensor {.inline, noinit.} = ty.dynamicCppCall("poisson", self.tensor, generator).to(ATensor).newTensor()
proc poisson*(self: Tensor, generator: pointer = nil): Tensor {.inline, noinit.} = dynamicCCall("at::poisson", self.tensor, generator).to(ATensor).newTensor()
proc native_norm*(ty: TensorType; self: Tensor, p: float = 2): Tensor {.inline, noinit.} = ty.dynamicCppCall("native_norm", self.tensor, p).to(ATensor).newTensor()
proc native_norm*(self: Tensor, p: float = 2): Tensor {.inline, noinit.} = dynamicCCall("at::native_norm", self.tensor, p).to(ATensor).newTensor()
proc norm*(ty: TensorType; self: Tensor, p: float = 2): Tensor {.inline, noinit.} = ty.dynamicCppCall("norm", self.tensor, p).to(ATensor).newTensor()
proc norm*(self: Tensor, p: float = 2): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("norm", p).to(ATensor).newTensor()
proc norm*(ty: TensorType; self: Tensor, p: float, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = ty.dynamicCppCall("norm", self.tensor, p, dim, keepdim).to(ATensor).newTensor()
proc norm*(self: Tensor, p: float, dim: int64, keepdim: bool = false): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("norm", p, dim, keepdim).to(ATensor).newTensor()
proc native_clone*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("native_clone", self.tensor).to(ATensor).newTensor()
proc native_clone*(self: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::native_clone", self.tensor).to(ATensor).newTensor()
proc clone*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("clone", self.tensor).to(ATensor).newTensor()
proc clone*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("clone").to(ATensor).newTensor()
proc native_resize_as_u*(ty: TensorType; self: Tensor, the_template: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("native_resize_as_", self.tensor, the_template.tensor).to(ATensor).newTensor()
proc native_resize_as_u*(self: Tensor, the_template: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::native_resize_as_", self.tensor, the_template.tensor).to(ATensor).newTensor()
proc resize_as_u*(ty: TensorType; self: Tensor, the_template: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("resize_as_", self.tensor, the_template.tensor).to(ATensor).newTensor()
proc resize_as_u*(self: Tensor, the_template: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("resize_as_", the_template.tensor).to(ATensor).newTensor()
proc native_pow*(ty: TensorType; self: Tensor, exponent: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("native_pow", self.tensor, exponent).to(ATensor).newTensor()
proc native_pow*(self: Tensor, exponent: float): Tensor {.inline, noinit.} = dynamicCCall("at::native_pow", self.tensor, exponent).to(ATensor).newTensor()
proc pow*(ty: TensorType; self: Tensor, exponent: float): Tensor {.inline, noinit.} = ty.dynamicCppCall("pow", self.tensor, exponent).to(ATensor).newTensor()
proc pow*(self: Tensor, exponent: float): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("pow", exponent).to(ATensor).newTensor()
proc native_zero_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("native_zero_", self.tensor).to(ATensor).newTensor()
proc native_zero_u*(self: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::native_zero_", self.tensor).to(ATensor).newTensor()
proc zero_u*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("zero_", self.tensor).to(ATensor).newTensor()
proc zero_u*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("zero_").to(ATensor).newTensor()
proc sub*(ty: TensorType; self: Tensor, other: Tensor, alpha: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("sub", self.tensor, other.tensor, alpha).to(ATensor).newTensor()
proc sub*(self: Tensor, other: Tensor, alpha: float = 1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("sub", other.tensor, alpha).to(ATensor).newTensor()
proc sub_u*(ty: TensorType; self: Tensor, other: Tensor, alpha: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("sub_", self.tensor, other.tensor, alpha).to(ATensor).newTensor()
proc sub_u*(self: Tensor, other: Tensor, alpha: float = 1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("sub_", other.tensor, alpha).to(ATensor).newTensor()
proc sub*(ty: TensorType; self: Tensor, other: float, alpha: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("sub", self.tensor, other, alpha).to(ATensor).newTensor()
proc sub*(self: Tensor, other: float, alpha: float = 1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("sub", other, alpha).to(ATensor).newTensor()
proc sub_u*(ty: TensorType; self: Tensor, other: float, alpha: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("sub_", self.tensor, other, alpha).to(ATensor).newTensor()
proc sub_u*(self: Tensor, other: float, alpha: float = 1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("sub_", other, alpha).to(ATensor).newTensor()
proc s_native_addmm*(ty: TensorType; self: Tensor, mat1: Tensor, mat2: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("s_native_addmm", self.tensor, mat1.tensor, mat2.tensor, beta, alpha).to(ATensor).newTensor()
proc s_native_addmm*(self: Tensor, mat1: Tensor, mat2: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = dynamicCCall("at::s_native_addmm", self.tensor, mat1.tensor, mat2.tensor, beta, alpha).to(ATensor).newTensor()
proc s_native_addmm_u*(ty: TensorType; self: Tensor, mat1: Tensor, mat2: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("s_native_addmm_", self.tensor, mat1.tensor, mat2.tensor, beta, alpha).to(ATensor).newTensor()
proc s_native_addmm_u*(self: Tensor, mat1: Tensor, mat2: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = dynamicCCall("at::s_native_addmm_", self.tensor, mat1.tensor, mat2.tensor, beta, alpha).to(ATensor).newTensor()
proc addmm*(ty: TensorType; self: Tensor, mat1: Tensor, mat2: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("addmm", self.tensor, mat1.tensor, mat2.tensor, beta, alpha).to(ATensor).newTensor()
proc addmm*(self: Tensor, mat1: Tensor, mat2: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("addmm", mat1.tensor, mat2.tensor, beta, alpha).to(ATensor).newTensor()
proc addmm_u*(ty: TensorType; self: Tensor, mat1: Tensor, mat2: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = ty.dynamicCppCall("addmm_", self.tensor, mat1.tensor, mat2.tensor, beta, alpha).to(ATensor).newTensor()
proc addmm_u*(self: Tensor, mat1: Tensor, mat2: Tensor, beta: float = 1, alpha: float = 1): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("addmm_", mat1.tensor, mat2.tensor, beta, alpha).to(ATensor).newTensor()
proc native_tensor*(ty: TensorType; self_ty: TensorType): Tensor {.inline, noinit.} = ty.dynamicCppCall("native_tensor", self_ty).to(ATensor).newTensor()
proc native_tensor*(self_ty: TensorType): Tensor {.inline, noinit.} = dynamicCCall("at::native_tensor", self_ty).to(ATensor).newTensor()
proc native_tensor*(ty: TensorType; self_ty: TensorType, size: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("native_tensor", self_ty, size).to(ATensor).newTensor()
proc native_tensor*(self_ty: TensorType, size: IntList): Tensor {.inline, noinit.} = dynamicCCall("at::native_tensor", self_ty, size).to(ATensor).newTensor()
proc tensor*(ty: TensorType; dtype: TensorType): Tensor {.inline, noinit.} = ty.dynamicCppCall("tensor", dtype).to(ATensor).newTensor()
proc tensor*(ty: TensorType; dtype: TensorType, size: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("tensor", dtype, size).to(ATensor).newTensor()
proc native_sparse_coo_tensor*(ty: TensorType; indices: Tensor, values: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("native_sparse_coo_tensor", indices.tensor, values.tensor).to(ATensor).newTensor()
proc native_sparse_coo_tensor*(ty: TensorType; indices: Tensor, values: Tensor, size: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("native_sparse_coo_tensor", indices.tensor, values.tensor, size).to(ATensor).newTensor()
proc sparse_coo_tensor*(ty: TensorType; indices: Tensor, values: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("sparse_coo_tensor", indices.tensor, values.tensor).to(ATensor).newTensor()
proc sparse_coo_tensor*(ty: TensorType; indices: Tensor, values: Tensor, size: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("sparse_coo_tensor", indices.tensor, values.tensor, size).to(ATensor).newTensor()
proc u_native_sparse_coo_tensor_unsafe*(ty: TensorType; indices: Tensor, values: Tensor, size: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("_native_sparse_coo_tensor_unsafe", indices.tensor, values.tensor, size).to(ATensor).newTensor()
proc u_sparse_coo_tensor_unsafe*(ty: TensorType; indices: Tensor, values: Tensor, size: IntList): Tensor {.inline, noinit.} = ty.dynamicCppCall("_sparse_coo_tensor_unsafe", indices.tensor, values.tensor, size).to(ATensor).newTensor()
proc u_sparse_coo_tensor_unsafe*(indices: Tensor, values: Tensor, size: IntList): Tensor {.inline, noinit.} = dynamicCCall("at::_sparse_coo_tensor_unsafe", indices.tensor, values.tensor, size).to(ATensor).newTensor()
proc sparse_raw_resize_u*(ty: TensorType; self: Tensor, size: IntList, sparseDims: int64, denseDims: int64): Tensor {.inline, noinit.} = ty.dynamicCppCall("sparse_raw_resize_", self.tensor, size, sparseDims, denseDims).to(ATensor).newTensor()
proc sparse_raw_resize_u*(self: Tensor, size: IntList, sparseDims: int64, denseDims: int64): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("sparse_raw_resize_", size, sparseDims, denseDims).to(ATensor).newTensor()
proc u_sparse_mask*(ty: TensorType; self: Tensor, mask: ASparseTensorRef): Tensor {.inline, noinit.} = ty.dynamicCppCall("_sparse_mask", self.tensor, mask).to(ATensor).newTensor()
proc u_sparse_mask*(self: Tensor, mask: ASparseTensorRef): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_sparse_mask", mask).to(ATensor).newTensor()
proc to_dense*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("to_dense", self.tensor).to(ATensor).newTensor()
proc to_dense*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("to_dense").to(ATensor).newTensor()
proc u_sparseDims*(ty: TensorType; self: Tensor): int64 {.inline, noinit.} = ty.dynamicCppCall("_sparseDims", self.tensor).to(int64)
proc u_sparseDims*(self: Tensor): int64 {.inline, noinit.} = self.tensor.dynamicCppCall("_sparseDims").to(int64)
proc u_dimI*(ty: TensorType; self: Tensor): int64 {.inline, noinit.} = ty.dynamicCppCall("_dimI", self.tensor).to(int64)
proc u_dimI*(self: Tensor): int64 {.inline, noinit.} = self.tensor.dynamicCppCall("_dimI").to(int64)
proc u_denseDims*(ty: TensorType; self: Tensor): int64 {.inline, noinit.} = ty.dynamicCppCall("_denseDims", self.tensor).to(int64)
proc u_denseDims*(self: Tensor): int64 {.inline, noinit.} = self.tensor.dynamicCppCall("_denseDims").to(int64)
proc u_dimV*(ty: TensorType; self: Tensor): int64 {.inline, noinit.} = ty.dynamicCppCall("_dimV", self.tensor).to(int64)
proc u_dimV*(self: Tensor): int64 {.inline, noinit.} = self.tensor.dynamicCppCall("_dimV").to(int64)
proc u_nnz*(ty: TensorType; self: Tensor): int64 {.inline, noinit.} = ty.dynamicCppCall("_nnz", self.tensor).to(int64)
proc u_nnz*(self: Tensor): int64 {.inline, noinit.} = self.tensor.dynamicCppCall("_nnz").to(int64)
proc coalesce*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("coalesce", self.tensor).to(ATensor).newTensor()
proc coalesce*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("coalesce").to(ATensor).newTensor()
proc is_coalesced*(ty: TensorType; self: Tensor): bool {.inline, noinit.} = ty.dynamicCppCall("is_coalesced", self.tensor).to(bool)
proc is_coalesced*(self: Tensor): bool {.inline, noinit.} = self.tensor.dynamicCppCall("is_coalesced").to(bool)
proc u_indices*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_indices", self.tensor).to(ATensor).newTensor()
proc u_indices*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_indices").to(ATensor).newTensor()
proc u_values*(ty: TensorType; self: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("_values", self.tensor).to(ATensor).newTensor()
proc u_values*(self: Tensor): Tensor {.inline, noinit.} = self.tensor.dynamicCppCall("_values").to(ATensor).newTensor()
proc hspmm*(ty: TensorType; mat1: Tensor, mat2: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("hspmm", mat1.tensor, mat2.tensor).to(ATensor).newTensor()
proc hspmm*(mat1: Tensor, mat2: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::hspmm", mat1.tensor, mat2.tensor).to(ATensor).newTensor()
proc raw_copy_sparse_u*(ty: TensorType; self: Tensor, src: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("raw_copy_sparse_", self.tensor, src.tensor).to(ATensor).newTensor()
proc raw_copy_sparse_u*(self: Tensor, src: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::raw_copy_sparse_", self.tensor, src.tensor).to(ATensor).newTensor()
proc numel*(ty: TensorType; self: Tensor): int64 {.inline, noinit.} = ty.dynamicCppCall("numel", self.tensor).to(int64)
proc numel*(self: Tensor): int64 {.inline, noinit.} = self.tensor.dynamicCppCall("numel").to(int64)
proc unbind*(ty: TensorType; self: Tensor, dim: int64 = 0): TensorList {.inline, noinit.} = ty.dynamicCppCall("unbind", self.tensor, dim).to(TensorList)
proc unbind*(self: Tensor, dim: int64 = 0): TensorList {.inline, noinit.} = self.tensor.dynamicCppCall("unbind", dim).to(TensorList)
proc native_get_device*(ty: TensorType; self: Tensor): int64 {.inline, noinit.} = ty.dynamicCppCall("native_get_device", self.tensor).to(int64)
proc native_get_device*(self: Tensor): int64 {.inline, noinit.} = dynamicCCall("at::native_get_device", self.tensor).to(int64)
proc get_device*(ty: TensorType; self: Tensor): int64 {.inline, noinit.} = ty.dynamicCppCall("get_device", self.tensor).to(int64)
proc get_device*(self: Tensor): int64 {.inline, noinit.} = self.tensor.dynamicCppCall("get_device").to(int64)
proc meshgrid*(ty: TensorType; tensors: TensorList): TensorList {.inline, noinit.} = ty.dynamicCppCall("meshgrid", tensors).to(TensorList)
proc meshgrid*(tensors: TensorList): TensorList {.inline, noinit.} = dynamicCCall("at::meshgrid", tensors).to(TensorList)
proc u_local_scalar*(ty: TensorType; self: Tensor): float {.inline, noinit.} = ty.dynamicCppCall("_local_scalar", self.tensor).to(float)
proc u_local_scalar*(self: Tensor): float {.inline, noinit.} = self.tensor.dynamicCppCall("_local_scalar").to(float)
proc u_local_scalar_dense*(ty: TensorType; self: Tensor): float {.inline, noinit.} = ty.dynamicCppCall("_local_scalar_dense", self.tensor).to(float)
proc u_local_scalar_dense*(self: Tensor): float {.inline, noinit.} = dynamicCCall("at::_local_scalar_dense", self.tensor).to(float)
proc u_thnn_fused_lstm_cell*(ty: TensorType; input_gates: Tensor, hidden_gates: Tensor, cx: Tensor, input_bias: Tensor, hidden_bias: Tensor): tuple[result0: Tensor, result1: Tensor, result2: Tensor] {.inline, noinit.} = ty.dynamicCppCall("_thnn_fused_lstm_cell", input_gates.tensor, hidden_gates.tensor, cx.tensor, input_bias.tensor, hidden_bias.tensor).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc u_thnn_fused_lstm_cell*(input_gates: Tensor, hidden_gates: Tensor, cx: Tensor, input_bias: Tensor, hidden_bias: Tensor): tuple[result0: Tensor, result1: Tensor, result2: Tensor] {.inline, noinit.} = dynamicCCall("at::_thnn_fused_lstm_cell", input_gates.tensor, hidden_gates.tensor, cx.tensor, input_bias.tensor, hidden_bias.tensor).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc u_thnn_fused_lstm_cell_backward*(ty: TensorType; grad_hy: Tensor, grad_cy: Tensor, cx: Tensor, cy: Tensor, workspace: Tensor, has_bias: bool): tuple[result0: Tensor, result1: Tensor, result2: Tensor, result3: Tensor, result4: Tensor] {.inline, noinit.} = ty.dynamicCppCall("_thnn_fused_lstm_cell_backward", grad_hy.tensor, grad_cy.tensor, cx.tensor, cy.tensor, workspace.tensor, has_bias).to(StdTuple5[ATensor, ATensor, ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc u_thnn_fused_lstm_cell_backward*(grad_hy: Tensor, grad_cy: Tensor, cx: Tensor, cy: Tensor, workspace: Tensor, has_bias: bool): tuple[result0: Tensor, result1: Tensor, result2: Tensor, result3: Tensor, result4: Tensor] {.inline, noinit.} = dynamicCCall("at::_thnn_fused_lstm_cell_backward", grad_hy.tensor, grad_cy.tensor, cx.tensor, cy.tensor, workspace.tensor, has_bias).to(StdTuple5[ATensor, ATensor, ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc u_thnn_fused_gru_cell*(ty: TensorType; input_gates: Tensor, hidden_gates: Tensor, hx: Tensor, input_bias: Tensor, hidden_bias: Tensor): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = ty.dynamicCppCall("_thnn_fused_gru_cell", input_gates.tensor, hidden_gates.tensor, hx.tensor, input_bias.tensor, hidden_bias.tensor).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc u_thnn_fused_gru_cell*(input_gates: Tensor, hidden_gates: Tensor, hx: Tensor, input_bias: Tensor, hidden_bias: Tensor): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = dynamicCCall("at::_thnn_fused_gru_cell", input_gates.tensor, hidden_gates.tensor, hx.tensor, input_bias.tensor, hidden_bias.tensor).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc u_thnn_fused_gru_cell_backward*(ty: TensorType; grad_hy: Tensor, workspace: Tensor, has_bias: bool): tuple[result0: Tensor, result1: Tensor, result2: Tensor, result3: Tensor, result4: Tensor] {.inline, noinit.} = ty.dynamicCppCall("_thnn_fused_gru_cell_backward", grad_hy.tensor, workspace.tensor, has_bias).to(StdTuple5[ATensor, ATensor, ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc u_thnn_fused_gru_cell_backward*(grad_hy: Tensor, workspace: Tensor, has_bias: bool): tuple[result0: Tensor, result1: Tensor, result2: Tensor, result3: Tensor, result4: Tensor] {.inline, noinit.} = dynamicCCall("at::_thnn_fused_gru_cell_backward", grad_hy.tensor, workspace.tensor, has_bias).to(StdTuple5[ATensor, ATensor, ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc lstm*(ty: TensorType; input: Tensor, hx: TensorList, params: TensorList, has_biases: bool, num_layers: int64, dropout: float64, train: bool, bidirectional: bool, batch_first: bool): tuple[result0: Tensor, result1: Tensor, result2: Tensor] {.inline, noinit.} = ty.dynamicCppCall("lstm", input.tensor, hx, params, has_biases, num_layers, dropout, train, bidirectional, batch_first).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc lstm*(input: Tensor, hx: TensorList, params: TensorList, has_biases: bool, num_layers: int64, dropout: float64, train: bool, bidirectional: bool, batch_first: bool): tuple[result0: Tensor, result1: Tensor, result2: Tensor] {.inline, noinit.} = dynamicCCall("at::lstm", input.tensor, hx, params, has_biases, num_layers, dropout, train, bidirectional, batch_first).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc lstm*(ty: TensorType; data: Tensor, batch_sizes: Tensor, hx: TensorList, params: TensorList, has_biases: bool, num_layers: int64, dropout: float64, train: bool, bidirectional: bool): tuple[result0: Tensor, result1: Tensor, result2: Tensor] {.inline, noinit.} = ty.dynamicCppCall("lstm", data.tensor, batch_sizes.tensor, hx, params, has_biases, num_layers, dropout, train, bidirectional).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc lstm*(data: Tensor, batch_sizes: Tensor, hx: TensorList, params: TensorList, has_biases: bool, num_layers: int64, dropout: float64, train: bool, bidirectional: bool): tuple[result0: Tensor, result1: Tensor, result2: Tensor] {.inline, noinit.} = dynamicCCall("at::lstm", data.tensor, batch_sizes.tensor, hx, params, has_biases, num_layers, dropout, train, bidirectional).to(StdTuple3[ATensor, ATensor, ATensor]).toNimTuple().newTensors()
proc gru*(ty: TensorType; input: Tensor, hx: Tensor, params: TensorList, has_biases: bool, num_layers: int64, dropout: float64, train: bool, bidirectional: bool, batch_first: bool): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = ty.dynamicCppCall("gru", input.tensor, hx.tensor, params, has_biases, num_layers, dropout, train, bidirectional, batch_first).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc gru*(input: Tensor, hx: Tensor, params: TensorList, has_biases: bool, num_layers: int64, dropout: float64, train: bool, bidirectional: bool, batch_first: bool): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = dynamicCCall("at::gru", input.tensor, hx.tensor, params, has_biases, num_layers, dropout, train, bidirectional, batch_first).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc gru*(ty: TensorType; data: Tensor, batch_sizes: Tensor, hx: Tensor, params: TensorList, has_biases: bool, num_layers: int64, dropout: float64, train: bool, bidirectional: bool): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = ty.dynamicCppCall("gru", data.tensor, batch_sizes.tensor, hx.tensor, params, has_biases, num_layers, dropout, train, bidirectional).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc gru*(data: Tensor, batch_sizes: Tensor, hx: Tensor, params: TensorList, has_biases: bool, num_layers: int64, dropout: float64, train: bool, bidirectional: bool): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = dynamicCCall("at::gru", data.tensor, batch_sizes.tensor, hx.tensor, params, has_biases, num_layers, dropout, train, bidirectional).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc rnn_tanh*(ty: TensorType; input: Tensor, hx: Tensor, params: TensorList, has_biases: bool, num_layers: int64, dropout: float64, train: bool, bidirectional: bool, batch_first: bool): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = ty.dynamicCppCall("rnn_tanh", input.tensor, hx.tensor, params, has_biases, num_layers, dropout, train, bidirectional, batch_first).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc rnn_tanh*(input: Tensor, hx: Tensor, params: TensorList, has_biases: bool, num_layers: int64, dropout: float64, train: bool, bidirectional: bool, batch_first: bool): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = dynamicCCall("at::rnn_tanh", input.tensor, hx.tensor, params, has_biases, num_layers, dropout, train, bidirectional, batch_first).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc rnn_tanh*(ty: TensorType; data: Tensor, batch_sizes: Tensor, hx: Tensor, params: TensorList, has_biases: bool, num_layers: int64, dropout: float64, train: bool, bidirectional: bool): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = ty.dynamicCppCall("rnn_tanh", data.tensor, batch_sizes.tensor, hx.tensor, params, has_biases, num_layers, dropout, train, bidirectional).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc rnn_tanh*(data: Tensor, batch_sizes: Tensor, hx: Tensor, params: TensorList, has_biases: bool, num_layers: int64, dropout: float64, train: bool, bidirectional: bool): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = dynamicCCall("at::rnn_tanh", data.tensor, batch_sizes.tensor, hx.tensor, params, has_biases, num_layers, dropout, train, bidirectional).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc rnn_relu*(ty: TensorType; input: Tensor, hx: Tensor, params: TensorList, has_biases: bool, num_layers: int64, dropout: float64, train: bool, bidirectional: bool, batch_first: bool): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = ty.dynamicCppCall("rnn_relu", input.tensor, hx.tensor, params, has_biases, num_layers, dropout, train, bidirectional, batch_first).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc rnn_relu*(input: Tensor, hx: Tensor, params: TensorList, has_biases: bool, num_layers: int64, dropout: float64, train: bool, bidirectional: bool, batch_first: bool): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = dynamicCCall("at::rnn_relu", input.tensor, hx.tensor, params, has_biases, num_layers, dropout, train, bidirectional, batch_first).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc rnn_relu*(ty: TensorType; data: Tensor, batch_sizes: Tensor, hx: Tensor, params: TensorList, has_biases: bool, num_layers: int64, dropout: float64, train: bool, bidirectional: bool): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = ty.dynamicCppCall("rnn_relu", data.tensor, batch_sizes.tensor, hx.tensor, params, has_biases, num_layers, dropout, train, bidirectional).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc rnn_relu*(data: Tensor, batch_sizes: Tensor, hx: Tensor, params: TensorList, has_biases: bool, num_layers: int64, dropout: float64, train: bool, bidirectional: bool): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = dynamicCCall("at::rnn_relu", data.tensor, batch_sizes.tensor, hx.tensor, params, has_biases, num_layers, dropout, train, bidirectional).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc lstm_cell*(ty: TensorType; input: Tensor, hx: TensorList, w_ih: Tensor, w_hh: Tensor, b_ih: Tensor, b_hh: Tensor): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = ty.dynamicCppCall("lstm_cell", input.tensor, hx, w_ih.tensor, w_hh.tensor, b_ih.tensor, b_hh.tensor).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc lstm_cell*(input: Tensor, hx: TensorList, w_ih: Tensor, w_hh: Tensor, b_ih: Tensor, b_hh: Tensor): tuple[result0: Tensor, result1: Tensor] {.inline, noinit.} = dynamicCCall("at::lstm_cell", input.tensor, hx, w_ih.tensor, w_hh.tensor, b_ih.tensor, b_hh.tensor).to(StdTuple2[ATensor, ATensor]).toNimTuple().newTensors()
proc gru_cell*(ty: TensorType; input: Tensor, hx: Tensor, w_ih: Tensor, w_hh: Tensor, b_ih: Tensor, b_hh: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("gru_cell", input.tensor, hx.tensor, w_ih.tensor, w_hh.tensor, b_ih.tensor, b_hh.tensor).to(ATensor).newTensor()
proc gru_cell*(input: Tensor, hx: Tensor, w_ih: Tensor, w_hh: Tensor, b_ih: Tensor, b_hh: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::gru_cell", input.tensor, hx.tensor, w_ih.tensor, w_hh.tensor, b_ih.tensor, b_hh.tensor).to(ATensor).newTensor()
proc rnn_tanh_cell*(ty: TensorType; input: Tensor, hx: Tensor, w_ih: Tensor, w_hh: Tensor, b_ih: Tensor, b_hh: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("rnn_tanh_cell", input.tensor, hx.tensor, w_ih.tensor, w_hh.tensor, b_ih.tensor, b_hh.tensor).to(ATensor).newTensor()
proc rnn_tanh_cell*(input: Tensor, hx: Tensor, w_ih: Tensor, w_hh: Tensor, b_ih: Tensor, b_hh: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::rnn_tanh_cell", input.tensor, hx.tensor, w_ih.tensor, w_hh.tensor, b_ih.tensor, b_hh.tensor).to(ATensor).newTensor()
proc rnn_relu_cell*(ty: TensorType; input: Tensor, hx: Tensor, w_ih: Tensor, w_hh: Tensor, b_ih: Tensor, b_hh: Tensor): Tensor {.inline, noinit.} = ty.dynamicCppCall("rnn_relu_cell", input.tensor, hx.tensor, w_ih.tensor, w_hh.tensor, b_ih.tensor, b_hh.tensor).to(ATensor).newTensor()
proc rnn_relu_cell*(input: Tensor, hx: Tensor, w_ih: Tensor, w_hh: Tensor, b_ih: Tensor, b_hh: Tensor): Tensor {.inline, noinit.} = dynamicCCall("at::rnn_relu_cell", input.tensor, hx.tensor, w_ih.tensor, w_hh.tensor, b_ih.tensor, b_hh.tensor).to(ATensor).newTensor()
